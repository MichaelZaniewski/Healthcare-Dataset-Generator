#!/usr/bin/env python3
# Standalone Healthcare Dataset Generator 

import argparse, os, sys, re, json, glob, subprocess, tempfile, base64
from pathlib import Path
import pandas as pd
import numpy as np

BASE_B64 = "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uMwoiIiIKSGVhbHRoY2FyZSBEYXRhc2V0IEdlbmVyYXRvciAodjEzLjIpCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpDaGFuZ2VzIHZzIHYxMi41OgotIFJlZHVjZSBIZWFydCBkaXNlYXNlIHByZXZhbGVuY2UgdmlhIHdlaWdodGVkIGNvbmRpdGlvbiBzZWxlY3Rpb24uCi0gTGltaXQgZGlzdGluY3QgY29uZGl0aW9ucyBwZXIgcGF0aWVudCB0byBtYXggMywgd2l0aCAx4oCTMiBtb3N0IGNvbW1vbiAo4omINTUlIG9uZSwgMzUlIHR3bywgMTAlIHRocmVlKS4KLSBLZWVwIGFsbCBwcmlvciBydWxlcyAoY2hpbGRiaXJ0aCBnYXRpbmcgMjXigJM1MCBmZW1hbGUsIGNoaWxkYmlydGggY2FwIOKJpDIsIHBvc3RwYXJ0dW0gZm9sbG93LXVwcywgaGV0ZXJvZ2VuZWl0eSwKICBMT1MgcnVsZXMsIGJpbGxpbmcgbG9naWMsIHZhbGlkYXRpb24pLgoKUnVuIChXaW5kb3dzKToKICAgIHBpcCBpbnN0YWxsIHBhbmRhcyBudW1weSBmYWtlcgogICAgcHl0aG9uIGhlYWx0aGNhcmVfZGF0YXNldF9nZW5lcmF0b3JfdjEyXzYucHkgLS1wYXRpZW50cyA1MDAwMCAtLW1pbm9yLXNhbWUtZGF5LXJhdGUgMC42IC0tdmFsaWRhdGUKIiIiCgppbXBvcnQgYXJncGFyc2UKaW1wb3J0IHJhbmRvbQpmcm9tIHBhdGhsaWIgaW1wb3J0IFBhdGgKaW1wb3J0IG51bXB5IGFzIG5wCmltcG9ydCBwYW5kYXMgYXMgcGQKZnJvbSBmYWtlciBpbXBvcnQgRmFrZXIKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIFJlZmVyZW5jZSBEYXRhCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKQ09ORElUSU9OUyA9IHsKICAgICJIaWdoIGJsb29kIHByZXNzdXJlIjogeyJjYXRlZ29yeSI6ICJjaHJvbmljIiwgImxvcyI6ICgwLCAyKSwgImFkdWx0X29ubHkiOiBUcnVlLCAgInNhbWVfZGF5X29rIjogVHJ1ZX0sCiAgICAiRGlhYmV0ZXMiOiAgICAgICAgICAgIHsiY2F0ZWdvcnkiOiAiY2hyb25pYyIsICJsb3MiOiAoMSwgNCksICJhZHVsdF9vbmx5IjogRmFsc2UsICJzYW1lX2RheV9vayI6IFRydWV9LAogICAgIkFydGhyaXRpcyI6ICAgICAgICAgICB7ImNhdGVnb3J5IjogImNocm9uaWMiLCAibG9zIjogKDEsIDMpLCAiYWR1bHRfb25seSI6IFRydWUsICAic2FtZV9kYXlfb2siOiBUcnVlfSwKICAgICJBc3RobWEiOiAgICAgICAgICAgICAgeyJjYXRlZ29yeSI6ICJjaHJvbmljIiwgImxvcyI6ICgwLCAyKSwgImFkdWx0X29ubHkiOiBGYWxzZSwgInNhbWVfZGF5X29rIjogVHJ1ZX0sCiAgICAiQ2FuY2VyIjogICAgICAgICAgICAgIHsiY2F0ZWdvcnkiOiAiY29tcGxleCIsICJsb3MiOiAoNSwxMCksICJhZHVsdF9vbmx5IjogRmFsc2UsICJzYW1lX2RheV9vayI6IEZhbHNlfSwKICAgICJCcm9rZW4gYm9uZXMiOiAgICAgICAgeyJjYXRlZ29yeSI6ICJhY3V0ZSIsICAgImxvcyI6ICgwLCA1KSwgImFkdWx0X29ubHkiOiBGYWxzZSwgInNhbWVfZGF5X29rIjogVHJ1ZX0sCiAgICAiSGVhcnQgZGlzZWFzZSI6ICAgICAgIHsiY2F0ZWdvcnkiOiAiY29tcGxleCIsICJsb3MiOiAoNSwxMCksICJhZHVsdF9vbmx5IjogVHJ1ZSwgICJzYW1lX2RheV9vayI6IEZhbHNlfSwKICAgICJQbmV1bW9uaWEiOiAgICAgICAgICAgeyJjYXRlZ29yeSI6ICJhY3V0ZSIsICAgImxvcyI6ICgyLCA3KSwgImFkdWx0X29ubHkiOiBGYWxzZSwgInNhbWVfZGF5X29rIjogRmFsc2V9LAogICAgIkZsdSI6ICAgICAgICAgICAgICAgICB7ImNhdGVnb3J5IjogIm1pbm9yIiwgICAibG9zIjogKDAsIDIpLCAiYWR1bHRfb25seSI6IEZhbHNlLCAic2FtZV9kYXlfb2siOiBUcnVlfSwKICAgICJNaWdyYWluZSI6ICAgICAgICAgICAgeyJjYXRlZ29yeSI6ICJtaW5vciIsICAgImxvcyI6ICgwLCAxKSwgImFkdWx0X29ubHkiOiBGYWxzZSwgInNhbWVfZGF5X29rIjogVHJ1ZX0sCiAgICAiRGVwcmVzc2lvbiI6ICAgICAgICAgIHsiY2F0ZWdvcnkiOiAiZGVwcmVzc2lvbiIsICJsb3MiOiAoMywgNyksICJhZHVsdF9vbmx5IjogRmFsc2UsICJzYW1lX2RheV9vayI6IEZhbHNlfSwKICAgICJBbnhpZXR5IjogICAgICAgICAgICAgeyJjYXRlZ29yeSI6ICJkZXByZXNzaW9uIiwgImxvcyI6ICgxLCAzKSwgImFkdWx0X29ubHkiOiBGYWxzZSwgInNhbWVfZGF5X29rIjogRmFsc2V9LAogICAgIkFsbGVyZ2llcyI6ICAgICAgICAgICB7ImNhdGVnb3J5IjogIm1pbm9yIiwgICAibG9zIjogKDAsIDEpLCAiYWR1bHRfb25seSI6IEZhbHNlLCAic2FtZV9kYXlfb2siOiBUcnVlfSwKICAgICJLaWRuZXkgZmFpbHVyZSI6ICAgICAgeyJjYXRlZ29yeSI6ICJjb21wbGV4IiwgImxvcyI6ICg1LDEwKSwgImFkdWx0X29ubHkiOiBUcnVlLCAgInNhbWVfZGF5X29rIjogRmFsc2V9LAogICAgIlN0cm9rZSI6ICAgICAgICAgICAgICB7ImNhdGVnb3J5IjogImNvbXBsZXgiLCAibG9zIjogKDUsMTApLCAiYWR1bHRfb25seSI6IFRydWUsICAic2FtZV9kYXlfb2siOiBGYWxzZX0sCiAgICAiQ09WSUQtMTkiOiAgICAgICAgICAgIHsiY2F0ZWdvcnkiOiAiYWN1dGUiLCAgICJsb3MiOiAoMywxNCksICJhZHVsdF9vbmx5IjogRmFsc2UsICJzYW1lX2RheV9vayI6IEZhbHNlfSwKICAgICJDaGlsZGJpcnRoIjogICAgICAgICAgeyJjYXRlZ29yeSI6ICJhY3V0ZSIsICAgImxvcyI6ICgxLCA1KSwgImFkdWx0X29ubHkiOiBUcnVlLCAgInNhbWVfZGF5X29rIjogRmFsc2V9LAp9CkNPTkRfTkFNRVMgPSBsaXN0KENPTkRJVElPTlMua2V5cygpKQoKVFJFQVRNRU5UUyA9IHsKICAgICJDYW5jZXIiOiAoIkNoZW1vdGhlcmFweSIsICJSYWRpYXRpb24gVGhlcmFweSIpLAogICAgIkRpYWJldGVzIjogKCJJbnN1bGluIFRoZXJhcHkiLCAiRGlldGFyeSBNYW5hZ2VtZW50IiksCiAgICAiQXJ0aHJpdGlzIjogKCJQaHlzaWNhbCBUaGVyYXB5IiwgIkpvaW50IEluamVjdGlvbnMiKSwKICAgICJBc3RobWEiOiAoIkluaGFsZXIiLCAiTmVidWxpemVyIFRoZXJhcHkiKSwKICAgICJIaWdoIGJsb29kIHByZXNzdXJlIjogKCJNZWRpY2F0aW9uIiwgIkxpZmVzdHlsZSBDb3Vuc2VsaW5nIiksCiAgICAiS2lkbmV5IGZhaWx1cmUiOiAoIkRpYWx5c2lzIiwgIlRyYW5zcGxhbnQgRXZhbHVhdGlvbiIpLAogICAgIlN0cm9rZSI6ICgiUmVoYWJpbGl0YXRpb24iLCAiTWVkaWNhdGlvbiIpLAogICAgIkhlYXJ0IGRpc2Vhc2UiOiAoIkJ5cGFzcyBTdXJnZXJ5IiwgIk1lZGljYXRpb24iKSwKICAgICJCcm9rZW4gYm9uZXMiOiAoIkNhc3QiLCAiU3VyZ2VyeSIpLAogICAgIkNoaWxkYmlydGgiOiAoIkRlbGl2ZXJ5IiwgIkNlc2FyZWFuIFNlY3Rpb24iKSwKICAgICJGbHUiOiAoIk1lZGljYXRpb24iLCAiUmVzdCAmIEZsdWlkcyIpLAogICAgIlBuZXVtb25pYSI6ICgiTWVkaWNhdGlvbiIsICJPeHlnZW4gVGhlcmFweSIpLAogICAgIk1pZ3JhaW5lIjogKCJNZWRpY2F0aW9uIiwgIlBhaW4gTWFuYWdlbWVudCIpLAogICAgIkFsbGVyZ2llcyI6ICgiTWVkaWNhdGlvbiIsICJBbGxlcmd5IFNob3RzIiksCiAgICAiQ09WSUQtMTkiOiAoIlN1cHBvcnRpdmUgQ2FyZSIsICJNZWRpY2F0aW9uIiksCiAgICAiRGVwcmVzc2lvbiI6ICgiVGhlcmFweSAoQ0JUKSIsICJNZWRpY2F0aW9uIiksCiAgICAiQW54aWV0eSI6ICgiQ291bnNlbGluZyIsICJNZWRpY2F0aW9uIiksCn0KCk1FRElDQVRJT05TID0gewogICAgIkhpZ2ggYmxvb2QgcHJlc3N1cmUiOiBbIkxpc2lub3ByaWwiLCAiQW1sb2RpcGluZSIsICJIeWRyb2NobG9yb3RoaWF6aWRlIiwgIk1ldG9wcm9sb2wiLCAiQXRlbm9sb2wiXSwKICAgICJEaWFiZXRlcyI6IFsiSW5zdWxpbiBnbGFyZ2luZSIsICJJbnN1bGluIGxpc3BybyIsICJNZXRmb3JtaW4iLCAiU2l0YWdsaXB0aW4iLCAiR2xpcGl6aWRlIl0sCiAgICAiQXJ0aHJpdGlzIjogWyJJYnVwcm9mZW4iLCAiTmFwcm94ZW4iLCAiQ2VsZWNveGliIl0sCiAgICAiQXN0aG1hIjogWyJBbGJ1dGVyb2wiLCAiQnVkZXNvbmlkZSIsICJGbHV0aWNhc29uZSIsICJNb250ZWx1a2FzdCJdLAogICAgIkNhbmNlciI6IFsiQ2lzcGxhdGluIiwgIlBhY2xpdGF4ZWwiLCAiQ3ljbG9waG9zcGhhbWlkZSIsICJEb3hvcnViaWNpbiJdLAogICAgIkhlYXJ0IGRpc2Vhc2UiOiBbIkF0b3J2YXN0YXRpbiIsICJDbG9waWRvZ3JlbCIsICJOaXRyb2dseWNlcmluIiwgIk1ldG9wcm9sb2wiXSwKICAgICJQbmV1bW9uaWEiOiBbIkF6aXRocm9teWNpbiIsICJBbW94aWNpbGxpbi1jbGF2dWxhbmF0ZSIsICJMZXZvZmxveGFjaW4iXSwKICAgICJGbHUiOiBbIk9zZWx0YW1pdmlyIl0sCiAgICAiTWlncmFpbmUiOiBbIlN1bWF0cmlwdGFuIiwgIlJpemF0cmlwdGFuIiwgIlByb3ByYW5vbG9sIiwgIlRvcGlyYW1hdGUiXSwKICAgICJBbGxlcmdpZXMiOiBbIkNldGlyaXppbmUiLCAiTG9yYXRhZGluZSIsICJGZXhvZmVuYWRpbmUiXSwKICAgICJDT1ZJRC0xOSI6IFsiUmVtZGVzaXZpciIsICJOaXJtYXRyZWx2aXIvcml0b25hdmlyIl0sCiAgICAiRGVwcmVzc2lvbiI6IFsiU2VydHJhbGluZSIsICJGbHVveGV0aW5lIiwgIkVzY2l0YWxvcHJhbSIsICJCdXByb3Bpb24iXSwKICAgICJBbnhpZXR5IjogWyJEaWF6ZXBhbSIsICJMb3JhemVwYW0iLCAiQ2xvbmF6ZXBhbSIsICJCdXNwaXJvbmUiXSwKICAgICJTdHJva2UiOiBbIkFzcGlyaW4iLCAiQ2xvcGlkb2dyZWwiLCAiQXRvcnZhc3RhdGluIl0sCiAgICAiS2lkbmV5IGZhaWx1cmUiOiBbIkVwb2V0aW4gYWxmYSIsICJDYWxjaXRyaW9sIl0sCn0KCkNIQVJHRV9SQU5HRVMgPSB7CiAgICAiY29tcGxleCI6ICgzMDAwMCwgMTEwMDAwKSwKICAgICJjaHJvbmljIjogKDMwMDAsIDIwMDAwKSwKICAgICJkZXByZXNzaW9uIjogKDEwMDAsIDcwMDApLAogICAgImFjdXRlIjogKDEwMDAsIDEyMDAwKSwKICAgICJtaW5vciI6ICgxMDAsIDUwMDApCn0KCkNPTVBMRVhfU0VUID0geyJDYW5jZXIiLCJLaWRuZXkgZmFpbHVyZSIsIlN0cm9rZSIsIkhlYXJ0IGRpc2Vhc2UifQoKQ09ORF9MQVRFX0JBU0UgPSB7CiAgICAiQ2FuY2VyIjogKDAuMjIsIDAuMjUpLAogICAgIktpZG5leSBmYWlsdXJlIjogKDAuMjAsIDAuMjMpLAogICAgIlN0cm9rZSI6ICgwLjE4LCAwLjIyKSwKICAgICJIZWFydCBkaXNlYXNlIjogKDAuMTYsIDAuMjApLAogICAgIlBuZXVtb25pYSI6ICgwLjEyLCAwLjE4KSwKICAgICJDT1ZJRC0xOSI6ICgwLjE0LCAwLjIwKSwKICAgICJCcm9rZW4gYm9uZXMiOiAoMC4xMCwgMC4xNSksCiAgICAiRGlhYmV0ZXMiOiAoMC4xMCwgMC4xNSksCiAgICAiQXJ0aHJpdGlzIjogKDAuMDgsIDAuMTIpLAogICAgIkFzdGhtYSI6ICgwLjA4LCAwLjEyKSwKICAgICJIaWdoIGJsb29kIHByZXNzdXJlIjogKDAuMDgsIDAuMTIpLAogICAgIkZsdSI6ICgwLjA2LCAwLjEwKSwKICAgICJBbGxlcmdpZXMiOiAoMC4wNSwgMC4wOCksCiAgICAiTWlncmFpbmUiOiAoMC4wNiwgMC4xMCksCiAgICAiRGVwcmVzc2lvbiI6ICgwLjA5LCAwLjEyKSwKICAgICJBbnhpZXR5IjogKDAuMDksIDAuMTIpLAogICAgIkNoaWxkYmlydGgiOiAoMC4wNywgMC4xMCksCn0KCiMgV2VpZ2h0ZWQgY29uZGl0aW9uIHNlbGVjdGlvbiB0byByZWR1Y2UgSGVhcnQgZGlzZWFzZSBmcmVxdWVuY3kKQkFTRV9DT05EX1dFSUdIVFMgPSB7YzogMS4wIGZvciBjIGluIENPTkRfTkFNRVN9CkJBU0VfQ09ORF9XRUlHSFRTWyJIZWFydCBkaXNlYXNlIl0gPSAwLjM1ICAjIGRvd24td2VpZ2h0IGhlYXJ0IGRpc2Vhc2UgdmlzaWJseQoKZGVmIGVsaWdpYmxlX2NvbmRpdGlvbnMoYWdlLCBnZW5kZXIpOgogICAgZWxpZyA9IFtdCiAgICBmb3IgYyBpbiBDT05EX05BTUVTOgogICAgICAgIG0gPSBDT05ESVRJT05TW2NdCiAgICAgICAgaWYgYWdlIDwgMTggYW5kIG1bImFkdWx0X29ubHkiXToKICAgICAgICAgICAgY29udGludWUKICAgICAgICBpZiBjID09ICJDaGlsZGJpcnRoIiBhbmQgbm90IChnZW5kZXIgPT0gIkZlbWFsZSIgYW5kIDI1IDw9IGFnZSA8PSA1MCk6CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgcmV0dXJuX3NldCA9IFRydWUKICAgICAgICBlbGlnLmFwcGVuZChjKQogICAgcmV0dXJuIGVsaWcKCmRlZiB3ZWlnaHRlZF9waWNrX2NvbmRpdGlvbihhZ2UsIGdlbmRlciwgcm5nLCBleGlzdGluZz1Ob25lLCBhbGxvd19uZXc9VHJ1ZSk6CiAgICBwb29sID0gZWxpZ2libGVfY29uZGl0aW9ucyhhZ2UsIGdlbmRlcikKICAgIGlmIG5vdCBhbGxvd19uZXcgYW5kIGV4aXN0aW5nOgogICAgICAgIHBvb2wgPSBbYyBmb3IgYyBpbiBwb29sIGlmIGMgaW4gZXhpc3RpbmddCiAgICAgICAgaWYgbm90IHBvb2wgYW5kIGV4aXN0aW5nOgogICAgICAgICAgICBwb29sID0gbGlzdChleGlzdGluZykKICAgIGlmIG5vdCBwb29sOgogICAgICAgIHBvb2wgPSBlbGlnaWJsZV9jb25kaXRpb25zKGFnZSwgZ2VuZGVyKQogICAgd2VpZ2h0cyA9IG5wLmFycmF5KFtCQVNFX0NPTkRfV0VJR0hUUy5nZXQoYywgMS4wKSBmb3IgYyBpbiBwb29sXSwgZHR5cGU9ZmxvYXQpCiAgICB3ZWlnaHRzID0gd2VpZ2h0cyAvIHdlaWdodHMuc3VtKCkKICAgIHJldHVybiBybmcuY2hvaWNlKHBvb2wsIHA9d2VpZ2h0cykKCmRlZiBzZXZlcml0eV9mcm9tX2xvcyhsKToKICAgIGlmIGwgPj0gNzogcmV0dXJuICJTZXZlcmUiCiAgICBpZiBsID49IDQ6IHJldHVybiAiTW9kZXJhdGUiCiAgICBpZiBsID49IDE6IHJldHVybiAiTWlsZCIKICAgIHJldHVybiAiTm9ybWFsIgoKZGVmIGFkanVzdF9zZXZlcml0eShjb25kLCB2aXNpdF9pbmRleCwgdG90YWxfdmlzaXRzKToKICAgIGlmIGNvbmQgaW4gWyJCcm9rZW4gYm9uZXMiLCJGbHUiLCJNaWdyYWluZSIsIkFsbGVyZ2llcyJdOgogICAgICAgIGlmIHZpc2l0X2luZGV4ID09IDA6CiAgICAgICAgICAgIHJldHVybiByYW5kb20uY2hvaWNlKFsiTWlsZCIsIk1vZGVyYXRlIl0pCiAgICAgICAgZWxpZiB2aXNpdF9pbmRleCA9PSB0b3RhbF92aXNpdHMgLSAxOgogICAgICAgICAgICByZXR1cm4gIk5vcm1hbCIKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gcmFuZG9tLmNob2ljZShbIk1pbGQiLCJOb3JtYWwiXSkKICAgIHJldHVybiBOb25lCgpkZWYgaW5pdGlhbF9jaGFyZ2UoY29uZCwgaG9zcF9tdWx0KToKICAgIGNhdCA9IENPTkRJVElPTlNbY29uZF1bImNhdGVnb3J5Il0KICAgIGxvLCBoaSA9IENIQVJHRV9SQU5HRVNbY2F0XQogICAgYmFzZSA9IG5wLnJhbmRvbS5yYW5kaW50KGxvLCBoaSsxKQogICAgcmV0dXJuIGludChiYXNlICogaG9zcF9tdWx0KQoKZGVmIGZvbGxvd3VwX2NoYXJnZShwcmV2X2NoYXJnZSwgY29uZCwgZmlyc3RfY2hhcmdlLCBob3NwX211bHQpOgogICAgY2F0ID0gQ09ORElUSU9OU1tjb25kXVsiY2F0ZWdvcnkiXQogICAgaWYgY2F0IGluIFsiY29tcGxleCIsImNocm9uaWMiLCJkZXByZXNzaW9uIl06CiAgICAgICAgZmFjdG9yID0gbnAucmFuZG9tLnVuaWZvcm0oMC42LCAwLjkpCiAgICBlbHNlOgogICAgICAgIGZhY3RvciA9IG5wLnJhbmRvbS51bmlmb3JtKDAuMywgMC43KQogICAgaWYgbnAucmFuZG9tLnJhbmQoKSA8IDAuMTg6CiAgICAgICAgZmFjdG9yID0gbnAucmFuZG9tLnVuaWZvcm0oMS4wNSwgMS4xNSkgICMgc21hbGwgYnVtcAogICAgbmV3X2NoYXJnZSA9IGludChwcmV2X2NoYXJnZSAqIGZhY3RvcikKICAgIG5ld19jaGFyZ2UgPSBtaW4obmV3X2NoYXJnZSwgZmlyc3RfY2hhcmdlKQogICAgcmV0dXJuIGludChuZXdfY2hhcmdlICogaG9zcF9tdWx0KQoKZGVmIGJ1aWxkX2RvY3Rvcl9ob3NwaXRhbF9wb29scyhmYWtlLCBuX2hvc3BpdGFscz0yNTAsIG5fZG9jdG9ycz0xMjAwLCBzZWVkPU5vbmUpOgogICAgcm5nID0gbnAucmFuZG9tLmRlZmF1bHRfcm5nKHNlZWQpCiAgICBob3NwaXRhbHMgPSBbZmFrZS5jb21wYW55KCkgKyAiIEhvc3BpdGFsIiBmb3IgXyBpbiByYW5nZShuX2hvc3BpdGFscyldCiAgICBkb2N0b3JzID0gW2Zha2UubmFtZSgpIGZvciBfIGluIHJhbmdlKG5fZG9jdG9ycyldCiAgICBkb2NfaG9zcF9tYXAgPSB7ZG9jOiByYW5kb20uc2FtcGxlKGhvc3BpdGFscywgaz1yYW5kb20uY2hvaWNlKFsxLDIsM10pKSBmb3IgZG9jIGluIGRvY3RvcnN9CiAgICBob3NwX3Byb2ZpbGVzID0ge30KICAgIGZvciBoIGluIGhvc3BpdGFsczoKICAgICAgICBzYW1lX2RheV9iaWFzID0gZmxvYXQobnAuY2xpcChybmcubm9ybWFsKDAsIDAuMDc1KSwgLTAuMTUsIDAuMTUpKQogICAgICAgIGxhdGVfbXVsdCA9IGZsb2F0KG5wLmNsaXAocm5nLmxvZ25vcm1hbChtZWFuPTAuMCwgc2lnbWE9MC4yNSksIDAuNywgMS41KSkKICAgICAgICBjaGFyZ2VfbXVsdCA9IGZsb2F0KHJuZy51bmlmb3JtKDAuOSwgMS4yKSkKICAgICAgICBob3NwX3Byb2ZpbGVzW2hdID0geyJzYW1lX2RheV9iaWFzIjogc2FtZV9kYXlfYmlhcywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXRlX211bHQiOiBsYXRlX211bHQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2hhcmdlX211bHQiOiBjaGFyZ2VfbXVsdH0KICAgIGRvY3Rvcl9wcm9maWxlcyA9IHt9CiAgICBmb3IgZCBpbiBkb2N0b3JzOgogICAgICAgIHN0eWxlID0gZmxvYXQobnAuY2xpcChybmcubm9ybWFsKDAsIDAuMDcpLCAtMC4xNSwgMC4xNSkpCiAgICAgICAgcnhfYmlhcyA9IGZsb2F0KG5wLmNsaXAocm5nLm5vcm1hbCgwLCAwLjA1KSwgLTAuMSwgMC4xKSkKICAgICAgICBkb2N0b3JfcHJvZmlsZXNbZF0gPSB7InN0eWxlIjogc3R5bGUsICJyeF9iaWFzIjogcnhfYmlhc30KICAgIHJldHVybiBkb2N0b3JzLCBob3NwaXRhbHMsIGRvY19ob3NwX21hcCwgaG9zcF9wcm9maWxlcywgZG9jdG9yX3Byb2ZpbGVzCgpkZWYgcGlja190cmVhdG1lbnQoY29uZCwgaXNfZmlyc3RfdmlzaXQsIHNldmVyaXR5LCBpc19mb2xsb3d1cCwgYnlwYXNzX3VzZWQ9RmFsc2UsIHJ4X2JpYXM9MC4wKToKICAgIHByaW1hcnksIHNlY29uZGFyeSA9IFRSRUFUTUVOVFNbY29uZF0KICAgIGlmIGlzX2ZpcnN0X3Zpc2l0OgogICAgICAgIG9wdGlvbnMgPSBbcHJpbWFyeSwgc2Vjb25kYXJ5LCAiTW9uaXRvcmluZyJdCiAgICAgICAgd2VpZ2h0cyA9IG5wLmFycmF5KFswLjcwLCAwLjI2LCAwLjA0IGlmIHNldmVyaXR5IGluIFsiTm9ybWFsIiwiTWlsZCJdIGVsc2UgMC4wXSwgZHR5cGU9ZmxvYXQpCiAgICBlbHNlOgogICAgICAgIG9wdGlvbnMgPSBbcHJpbWFyeSwgc2Vjb25kYXJ5LCAiTW9uaXRvcmluZyJdCiAgICAgICAgd2VpZ2h0cyA9IG5wLmFycmF5KFswLjUwLCAwLjIwLCAwLjMwXSwgZHR5cGU9ZmxvYXQpCiAgICBpZiBjb25kID09ICJIZWFydCBkaXNlYXNlIiBhbmQgYnlwYXNzX3VzZWQ6CiAgICAgICAgb3B0aW9ucyA9IFtzZWNvbmRhcnksICJNb25pdG9yaW5nIl0KICAgICAgICB3ZWlnaHRzID0gbnAuYXJyYXkoWzAuNjAsIDAuNDBdLCBkdHlwZT1mbG9hdCkKICAgIGlmICJNZWRpY2F0aW9uIiBpbiBvcHRpb25zOgogICAgICAgIGlkeCA9IG9wdGlvbnMuaW5kZXgoIk1lZGljYXRpb24iKQogICAgICAgIHdlaWdodHNbaWR4XSA9IG1heCgwLjAsIHdlaWdodHNbaWR4XSArIHJ4X2JpYXMpCiAgICBpZiB3ZWlnaHRzLnN1bSgpID09IDA6CiAgICAgICAgb3B0aW9ucyA9IFtwcmltYXJ5LCBzZWNvbmRhcnldCiAgICAgICAgd2VpZ2h0cyA9IG5wLmFycmF5KFswLjc0LCAwLjI2XSwgZHR5cGU9ZmxvYXQpCiAgICB3ZWlnaHRzID0gd2VpZ2h0cyAvIHdlaWdodHMuc3VtKCkKICAgIHJldHVybiBucC5yYW5kb20uY2hvaWNlKG9wdGlvbnMsIHA9d2VpZ2h0cykKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIFZhbGlkYXRpb24gKHN1bW1hcnkgcmVwb3J0KSAtLSAoc2FtZSBhcyB2MTIuNSB3aXRoIG9uZSBleHRyYSBsaW5lKQojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCmRlZiB2YWxpZGF0ZV9zdW1tYXJ5KHBhdGllbnRzLCB2aXNpdHMsIGJpbGxpbmcsIHRvZGF5X3N0ciwgb3V0ZGlyLCBiYXNlX21pbm9yX3NhbWVfZGF5KToKICAgIGltcG9ydCBwYW5kYXMgYXMgcGQKICAgIGZyb20gcGF0aGxpYiBpbXBvcnQgUGF0aAogICAgdG9kYXkgPSBwZC5UaW1lc3RhbXAodG9kYXlfc3RyKQogICAgc3VtbWFyeSA9IHt9CgogICAgc3VtbWFyeVsicGF0aWVudHNfdW5pcXVlX2lkcyJdID0gaW50KHBhdGllbnRzWyJwYXRpZW50X2lkIl0uaXNfdW5pcXVlKQogICAgc3VtbWFyeVsidmlzaXRzX3VuaXF1ZV9pZHMiXSA9IGludCh2aXNpdHNbInZpc2l0X2lkIl0uaXNfdW5pcXVlKQogICAgc3VtbWFyeVsiYmlsbGluZ191bmlxdWVfaWRzIl0gPSBpbnQoYmlsbGluZ1siYmlsbGluZ19pZCJdLmlzX3VuaXF1ZSkKCiAgICBzdW1tYXJ5WyJwYXRpZW50c19yb3dzIl0gPSBsZW4ocGF0aWVudHMpCiAgICBzdW1tYXJ5WyJ2aXNpdHNfcm93cyJdID0gbGVuKHZpc2l0cykKICAgIHN1bW1hcnlbImJpbGxpbmdfcm93cyJdID0gbGVuKGJpbGxpbmcpCiAgICBzdW1tYXJ5WyJ2aXNpdHNfbWlzc2luZ19iaWxsaW5nIl0gPSBpbnQobGVuKHZpc2l0cykgLSBiaWxsaW5nWyJ2aXNpdF9pZCJdLm51bmlxdWUoKSkKICAgIHN1bW1hcnlbIm11bHRpcGxlX2JpbGxpbmdzX3Blcl92aXNpdCJdID0gaW50KChiaWxsaW5nLmdyb3VwYnkoInZpc2l0X2lkIikuc2l6ZSgpID4gMSkuc3VtKCkpCgogICAgcF9hZ2VfdG9kYXkgPSAoKHBkLnRvX2RhdGV0aW1lKHRvZGF5KSAtIHBkLnRvX2RhdGV0aW1lKHBhdGllbnRzWyJkYXRlX29mX2JpcnRoIl0pKSAvLyBwZC5UaW1lZGVsdGEoZGF5cz0zNjUpKS5hc3R5cGUoaW50KQogICAgc3VtbWFyeVsicGF0aWVudF9hZ2VfbWlzbWF0Y2hlcyJdID0gaW50KChwX2FnZV90b2RheSAhPSBwYXRpZW50c1siYWdlIl0pLnN1bSgpKQogICAgdl9hZ2UgPSAoKHBkLnRvX2RhdGV0aW1lKHZpc2l0c1siZGF0ZV9vZl9hZG1pc3Npb24iXSkgLSBwZC50b19kYXRldGltZSh2aXNpdHNbImRhdGVfb2ZfYmlydGgiXSkpIC8vIHBkLlRpbWVkZWx0YShkYXlzPTM2NSkpLmFzdHlwZShpbnQpCiAgICBzdW1tYXJ5WyJ2aXNpdF9hZ2VfbWlzbWF0Y2hlcyJdID0gaW50KCh2X2FnZSAhPSB2aXNpdHNbImFnZSJdKS5zdW0oKSkKCiAgICBzdW1tYXJ5WyJibG9vZF90eXBlX2luY29uc2lzdGVuY2llcyJdID0gaW50KHZpc2l0cy5ncm91cGJ5KCJwYXRpZW50X2lkIilbImJsb29kX3R5cGUiXS5udW5pcXVlKCkuZ3QoMSkuc3VtKCkpCgogICAgaW5zdXJlZF9yYXRlID0gKHBhdGllbnRzWyJpbnN1cmFuY2VfcHJvdmlkZXIiXS5ub3RuYSgpLm1lYW4oKSkKICAgIHN1bW1hcnlbImluc3VyZWRfcmF0ZV9wY3QiXSA9IHJvdW5kKGZsb2F0KGluc3VyZWRfcmF0ZSoxMDApLCAyKQogICAgc3VtbWFyeVsicG9saWN5X3dpdGhvdXRfcHJvdmlkZXIiXSA9IGludCgoKHBhdGllbnRzWyJpbnN1cmFuY2VfcHJvdmlkZXIiXS5pc25hKCkpICYgKHBhdGllbnRzWyJpbnN1cmFuY2VfcG9saWN5X251bWJlciJdLm5vdG5hKCkpKS5zdW0oKSkKCiAgICB2X21lcmdlID0gdmlzaXRzLm1lcmdlKAogICAgICAgIHBhdGllbnRzW1sicGF0aWVudF9pZCIsImRhdGVfb2ZfYmlydGgiLCJnZW5kZXIiXV0sCiAgICAgICAgb249InBhdGllbnRfaWQiLCBob3c9ImxlZnQiLCBzdWZmaXhlcz0oIiIsICJfcCIpCiAgICApCiAgICAjIFByZWZlciB2aXNpdHMuZGF0ZV9vZl9iaXJ0aCBpZiBwcmVzZW50OyBvdGhlcndpc2UgdXNlIHBhdGllbnRzLmRhdGVfb2ZfYmlydGhfcAogICAgZG9iX2NvbCA9ICJkYXRlX29mX2JpcnRoIiBpZiAiZGF0ZV9vZl9iaXJ0aCIgaW4gdl9tZXJnZS5jb2x1bW5zIGVsc2UgImRhdGVfb2ZfYmlydGhfcCIKICAgIHZfbWVyZ2VbImFnZV9hdF92aXNpdCJdID0gKChwZC50b19kYXRldGltZSh2X21lcmdlWyJkYXRlX29mX2FkbWlzc2lvbiJdKSAtIHBkLnRvX2RhdGV0aW1lKHZfbWVyZ2VbZG9iX2NvbF0pKSAvLyBwZC5UaW1lZGVsdGEoZGF5cz0zNjUpKS5hc3R5cGUoaW50KQogICAgYWR1bHRfb25seSA9IHNldChbYyBmb3IgYyxtIGluIENPTkRJVElPTlMuaXRlbXMoKSBpZiBtWyJhZHVsdF9vbmx5Il1dKQogICAgc3VtbWFyeVsicGVkaWF0cmljX2dhdGluZ192aW9sYXRpb25zIl0gPSBpbnQoKCh2X21lcmdlWyJhZ2VfYXRfdmlzaXQiXSA8IDE4KSAmICh2X21lcmdlWyJjb25kaXRpb24iXS5pc2luKGFkdWx0X29ubHkpKSkuc3VtKCkpCiAgICAjIFVzZSB2aXNpdHMuZ2VuZGVyICh1bnN1ZmZpeGVkKSBpZiBwcmVzZW50OyBlbHNlIHBhdGllbnRzLmdlbmRlcl9wCiAgICBnZW5kZXJfY29sID0gImdlbmRlciIgaWYgImdlbmRlciIgaW4gdl9tZXJnZS5jb2x1bW5zIGVsc2UgImdlbmRlcl9wIgogICAgc3VtbWFyeVsiY2hpbGRiaXJ0aF9ub25fZmVtYWxlIl0gPSBpbnQoKCh2X21lcmdlWyJjb25kaXRpb24iXT09IkNoaWxkYmlydGgiKSAmICh2X21lcmdlW2dlbmRlcl9jb2xdIT0iRmVtYWxlIikpLnN1bSgpKQogICAgc3VtbWFyeVsiY2hpbGRiaXJ0aF9hZ2Vfb3V0X29mX3JhbmdlIl0gPSBpbnQoKCh2X21lcmdlWyJjb25kaXRpb24iXT09IkNoaWxkYmlydGgiKSAmIH52X21lcmdlWyJhZ2VfYXRfdmlzaXQiXS5iZXR3ZWVuKDI1LDUwKSkuc3VtKCkpCgogICAgdnYgPSB2aXNpdHMuY29weSgpLnNvcnRfdmFsdWVzKFsicGF0aWVudF9pZCIsImRhdGVfb2ZfYWRtaXNzaW9uIl0pCiAgICB2dlsiYWRtaXRfZHQiXSA9IHBkLnRvX2RhdGV0aW1lKHZ2WyJkYXRlX29mX2FkbWlzc2lvbiJdKTsgdnZbImRpc2NoX2R0Il0gPSBwZC50b19kYXRldGltZSh2dlsiZGF0ZV9vZl9kaXNjaGFyZ2UiXSkKICAgIHZ2WyJsb3MiXSA9ICh2dlsiZGlzY2hfZHQiXSAtIHZ2WyJhZG1pdF9kdCJdKS5kdC5kYXlzCiAgICBmb2xsb3dfZG9jX2hvc3BfaXNzdWVzID0gMDsgbG9zX3Zpb2wgPSAwCiAgICBmb3IgKHBpZCwgY29uZCksIGdycCBpbiB2di5ncm91cGJ5KFsicGF0aWVudF9pZCIsImNvbmRpdGlvbiJdKToKICAgICAgICBpZiBsZW4oZ3JwKSA+IDE6CiAgICAgICAgICAgIGQwLCBoMCA9IGdycC5pbG9jWzBdW1siZG9jdG9yIiwiaG9zcGl0YWwiXV0KICAgICAgICAgICAgaWYgbm90IGFsbChncnBbImRvY3RvciJdID09IGQwKTogZm9sbG93X2RvY19ob3NwX2lzc3VlcyArPSAxCiAgICAgICAgICAgIGlmIG5vdCBhbGwoZ3JwWyJob3NwaXRhbCJdID09IGgwKTogZm9sbG93X2RvY19ob3NwX2lzc3VlcyArPSAxCiAgICAgICAgICAgIGlmIChncnBbImxvcyJdLmlsb2NbMTpdID4gMikuYW55KCk6IGxvc192aW9sICs9IDEKICAgIHN1bW1hcnlbInNhbWVfY29uZGl0aW9uX2ZvbGxvd3VwX2RvY19ob3NwX21pc21hdGNoZXMiXSA9IGludChmb2xsb3dfZG9jX2hvc3BfaXNzdWVzKQogICAgc3VtbWFyeVsiZm9sbG93dXBfbG9zX2d0Ml9ieV9jb25kaXRpb24iXSA9IGludChsb3NfdmlvbCkKCiAgICBjb25kX2NvdW50cyA9IHZpc2l0cy5ncm91cGJ5KCJwYXRpZW50X2lkIilbImNvbmRpdGlvbiJdLm51bmlxdWUoKQogICAgc3VtbWFyeVsicGF0aWVudHNfd2l0aF9ndDNfY29uZGl0aW9ucyJdID0gaW50KChjb25kX2NvdW50cyA+IDMpLnN1bSgpKQogICAgc3VtbWFyeVsicGF0aWVudHNfZGlzdGluY3RfY29uZGl0aW9uc19kaXN0cmlidXRpb24iXSA9IGNvbmRfY291bnRzLnZhbHVlX2NvdW50cygpLnRvX2RpY3QoKQoKICAgIHZfbWVyZ2VbInllYXIiXSA9IHBkLnRvX2RhdGV0aW1lKHZfbWVyZ2VbImRhdGVfb2ZfYWRtaXNzaW9uIl0pLmR0LnllYXIKICAgIGNhcF92aW9sID0gKHZfbWVyZ2Vbdl9tZXJnZVsiY29uZGl0aW9uIl0uaXNpbihbIkZsdSIsIlBuZXVtb25pYSJdKV0KICAgICAgICAgICAgICAgIC5ncm91cGJ5KFsicGF0aWVudF9pZCIsImNvbmRpdGlvbiIsInllYXIiXSkuc2l6ZSgpLmd0KDMpLnN1bSgpKQogICAgc3VtbWFyeVsiZmx1X3BuZXVtb25pYV9jYXBfdmlvbGF0aW9ucyJdID0gaW50KGNhcF92aW9sKQoKICAgIGhiX3Zpb2wgPSAodmlzaXRzW3Zpc2l0c1siY29uZGl0aW9uIl09PSJIZWFydCBkaXNlYXNlIl0KICAgICAgICAgICAgICAgLmdyb3VwYnkoInBhdGllbnRfaWQiKVsidHJlYXRtZW50Il0uYXBwbHkobGFtYmRhIHM6IChzPT0iQnlwYXNzIFN1cmdlcnkiKS5zdW0oKSkuZ3QoMSkuc3VtKCkpCiAgICBzdW1tYXJ5WyJoZWFydF9ieXBhc3NfZ3QxX3Zpb2xhdGlvbnMiXSA9IGludChoYl92aW9sKQoKICAgIGNiX21hc2sgPSB2dlsiY29uZGl0aW9uIl0uZXEoIkNoaWxkYmlydGgiKQogICAgaWYgY2JfbWFzay5hbnkoKToKICAgICAgICBjYl9jb3VudHMgPSB2dltjYl9tYXNrXS5ncm91cGJ5KCJwYXRpZW50X2lkIikuc2l6ZSgpCiAgICAgICAgc3VtbWFyeVsiY2hpbGRiaXJ0aF92aXNpdHNfcGVyX3BhdGllbnRfZ3QyIl0gPSBpbnQoKGNiX2NvdW50cyA+IDIpLnN1bSgpKQogICAgICAgIGNiID0gdnZbY2JfbWFza10uY29weSgpCiAgICAgICAgY2JbIm9yZGVyIl0gPSBjYi5ncm91cGJ5KCJwYXRpZW50X2lkIilbImFkbWl0X2R0Il0ucmFuayhtZXRob2Q9ImZpcnN0IikKICAgICAgICBhbGxvd2VkX2ZvbGxvd3VwID0geyJQb3N0cGFydHVtIENoZWNrdXAiLCJNb25pdG9yaW5nIiwiTGFjdGF0aW9uIFN1cHBvcnQifQogICAgICAgIGZvbGxvd3VwcyA9IGNiW2NiWyJvcmRlciJdID4gMV0KICAgICAgICBpZiBsZW4oZm9sbG93dXBzKSA+IDA6CiAgICAgICAgICAgIGludmFsaWQgPSB+Zm9sbG93dXBzWyJ0cmVhdG1lbnQiXS5pc2luKGFsbG93ZWRfZm9sbG93dXApCiAgICAgICAgICAgIHN1bW1hcnlbImNoaWxkYmlydGhfZm9sbG93dXBfdHJlYXRtZW50X3Zpb2xhdGlvbnMiXSA9IGludChpbnZhbGlkLnN1bSgpKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHN1bW1hcnlbImNoaWxkYmlydGhfZm9sbG93dXBfdHJlYXRtZW50X3Zpb2xhdGlvbnMiXSA9IDAKICAgIGVsc2U6CiAgICAgICAgc3VtbWFyeVsiY2hpbGRiaXJ0aF92aXNpdHNfcGVyX3BhdGllbnRfZ3QyIl0gPSAwCiAgICAgICAgc3VtbWFyeVsiY2hpbGRiaXJ0aF9mb2xsb3d1cF90cmVhdG1lbnRfdmlvbGF0aW9ucyJdID0gMAoKICAgIHZiID0gYmlsbGluZy5tZXJnZSh2aXNpdHNbWyJ2aXNpdF9pZCIsInBhdGllbnRfaWQiLCJjb25kaXRpb24iXV0sIG9uPSJ2aXNpdF9pZCIsIGhvdz0ibGVmdCIpICAjIGJpbGxpbmdfZGF0ZSBjb21lcyBmcm9tIGJpbGxpbmcKICAgIGlzc3Vlc19leGNlZWRfZmlyc3QgPSAwOyBzbWFsbF9idW1wcyA9IDA7IG92ZXJhbGxfdXB3YXJkX3RyZW5kID0gMDsgdG90YWxfZm9sbG93dXBzID0gMAogICAgZm9yIChwaWQsIGNvbmQpLCBncnAgaW4gdmIuZ3JvdXBieShbInBhdGllbnRfaWQiLCJjb25kaXRpb24iXSk6CiAgICAgICAgZ3JwX3NvcnRlZCA9IGdycC5zb3J0X3ZhbHVlcygiYmlsbGluZ19kYXRlIikKICAgICAgICBjaGFyZ2VzID0gZ3JwX3NvcnRlZFsidG90YWxfY2hhcmdlIl0udG9saXN0KCkKICAgICAgICBpZiBub3QgY2hhcmdlczogY29udGludWUKICAgICAgICBmaXJzdF9jaGFyZ2UgPSBjaGFyZ2VzWzBdCiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKGNoYXJnZXMpKToKICAgICAgICAgICAgdG90YWxfZm9sbG93dXBzICs9IDEKICAgICAgICAgICAgaWYgY2hhcmdlc1tpXSA+IGZpcnN0X2NoYXJnZTogaXNzdWVzX2V4Y2VlZF9maXJzdCArPSAxCiAgICAgICAgICAgIGlmIGNoYXJnZXNbaV0gPiBjaGFyZ2VzW2ktMV06IHNtYWxsX2J1bXBzICs9IDEKICAgICAgICBpZiBsZW4oY2hhcmdlcykgPiAxIGFuZCBhbGwoY2hhcmdlc1tpXSA+PSBjaGFyZ2VzW2ktMV0gZm9yIGkgaW4gcmFuZ2UoMSxsZW4oY2hhcmdlcykpKToKICAgICAgICAgICAgb3ZlcmFsbF91cHdhcmRfdHJlbmQgKz0gMQogICAgc3VtbWFyeVsiYmlsbGluZ19mb2xsb3d1cF9leGNlZWRlZF9maXJzdCJdID0gaW50KGlzc3Vlc19leGNlZWRfZmlyc3QpCiAgICBzdW1tYXJ5WyJiaWxsaW5nX2ZvbGxvd3VwX2luY3JlYXNlX3BjdCJdID0gcm91bmQoMTAwKnNtYWxsX2J1bXBzL21heCh0b3RhbF9mb2xsb3d1cHMsMSksIDIpCiAgICBzdW1tYXJ5WyJiaWxsaW5nX292ZXJhbGxfdXB3YXJkX3RyZW5kX3J1bnMiXSA9IGludChvdmVyYWxsX3Vwd2FyZF90cmVuZCkKCiAgICBiID0gYmlsbGluZy5jb3B5KCkKICAgIGJbImV4cGVjdGVkX3BheW1lbnRfZGF0ZSJdID0gcGQudG9fZGF0ZXRpbWUoYlsiZXhwZWN0ZWRfcGF5bWVudF9kYXRlIl0pCiAgICBiWyJhY3R1YWxfcGF5bWVudF9kYXRlIl0gPSBwZC50b19kYXRldGltZShiWyJhY3R1YWxfcGF5bWVudF9kYXRlIl0sIGVycm9ycz0iY29lcmNlIikKICAgIHN1bW1hcnlbInBheW1lbnRfZnV0dXJlX2RhdGVzIl0gPSBpbnQoKGJbImFjdHVhbF9wYXltZW50X2RhdGUiXSA+IHBkLnRvX2RhdGV0aW1lKHRvZGF5KSkuc3VtKCkpCgogICAgY29uZF9tZXRhID0gcGQuRGF0YUZyYW1lLmZyb21fZGljdChDT05ESVRJT05TLCBvcmllbnQ9ImluZGV4IikKICAgIG1pbm9yX29rID0gc2V0KGNvbmRfbWV0YVsoY29uZF9tZXRhWyJzYW1lX2RheV9vayJdKSAmIChjb25kX21ldGFbImNhdGVnb3J5Il0uaXNpbihbIm1pbm9yIiwiY2hyb25pYyJdKSldLmluZGV4KQogICAgdnYyID0gdnZbdnZbImNvbmRpdGlvbiJdLmlzaW4obWlub3Jfb2spXS5jb3B5KCkKICAgIG1pbm9yX2xvd3NldiA9IHZ2Mlt2djJbInNldmVyaXR5Il0uaXNpbihbIk5vcm1hbCIsIk1pbGQiXSldCiAgICBpZiBsZW4obWlub3JfbG93c2V2KSA+IDA6CiAgICAgICAgYWN0dWFsX21pbm9yX3NhbWVfZGF5ID0gZmxvYXQoKHBkLnRvX2RhdGV0aW1lKG1pbm9yX2xvd3NldlsiZGF0ZV9vZl9kaXNjaGFyZ2UiXSkgPT0gcGQudG9fZGF0ZXRpbWUobWlub3JfbG93c2V2WyJkYXRlX29mX2FkbWlzc2lvbiJdKSkubWVhbigpKQogICAgICAgIHN1bW1hcnlbIm1pbm9yX3NhbWVfZGF5X3JhdGVfYWN0dWFsX3BjdCJdID0gcm91bmQoMTAwKmFjdHVhbF9taW5vcl9zYW1lX2RheSwgMikKICAgICAgICBzdW1tYXJ5WyJtaW5vcl9zYW1lX2RheV9yYXRlX3RhcmdldF9wY3QiXSA9IHJvdW5kKDEwMCpmbG9hdChiYXNlX21pbm9yX3NhbWVfZGF5KSwgMikKICAgIGVsc2U6CiAgICAgICAgc3VtbWFyeVsibWlub3Jfc2FtZV9kYXlfcmF0ZV9hY3R1YWxfcGN0Il0gPSAiTkEiCiAgICAgICAgc3VtbWFyeVsibWlub3Jfc2FtZV9kYXlfcmF0ZV90YXJnZXRfcGN0Il0gPSByb3VuZCgxMDAqZmxvYXQoYmFzZV9taW5vcl9zYW1lX2RheSksIDIpCgogICAgdnZbInNhbWVfZGF5Il0gPSAocGQudG9fZGF0ZXRpbWUodnZbImRhdGVfb2ZfZGlzY2hhcmdlIl0pID09IHBkLnRvX2RhdGV0aW1lKHZ2WyJkYXRlX29mX2FkbWlzc2lvbiJdKSkKICAgIGhvc3BfcmF0ZXMgPSB2di5ncm91cGJ5KCJob3NwaXRhbCIpWyJzYW1lX2RheSJdLm1lYW4oKQogICAgaWYgbGVuKGhvc3BfcmF0ZXMpID4gMToKICAgICAgICBzdW1tYXJ5WyJzYW1lX2RheV9yYXRlX2J5X2hvc3BpdGFsX3N0ZGRldl9wY3QiXSA9IHJvdW5kKDEwMCpmbG9hdChob3NwX3JhdGVzLnN0ZCgpKSwgMikKICAgICAgICBzdW1tYXJ5WyJzYW1lX2RheV9yYXRlX3RvcF9ob3NwaXRhbF9wY3QiXSA9IHJvdW5kKDEwMCpmbG9hdChob3NwX3JhdGVzLm1heCgpKSwgMikKICAgICAgICBzdW1tYXJ5WyJzYW1lX2RheV9yYXRlX292ZXJhbGxfcGN0Il0gPSByb3VuZCgxMDAqZmxvYXQodnZbInNhbWVfZGF5Il0ubWVhbigpKSwgMikKCiAgICBpbnN1cmVkX21hcCA9IHBhdGllbnRzW1sicGF0aWVudF9pZCIsImluc3VyYW5jZV9wcm92aWRlciJdXS5hc3NpZ24oaW5zdXJlZD1sYW1iZGEgeDogeFsiaW5zdXJhbmNlX3Byb3ZpZGVyIl0ubm90bmEoKSkKICAgIGJpID0gYi5tZXJnZShpbnN1cmVkX21hcCwgb249InBhdGllbnRfaWQiLCBob3c9ImxlZnQiKQogICAgbGF0ZV91bnBhaWRfaW5zdXJlZCA9IGZsb2F0KGJpW2JpWyJpbnN1cmVkIl09PVRydWVdWyJwYXltZW50X3N0YXR1cyJdLmVxKCJMYXRlLVVucGFpZCIpLm1lYW4oKSkKICAgIGxhdGVfdW5wYWlkX3VuaW5zdXJlZCA9IGZsb2F0KGJpW2JpWyJpbnN1cmVkIl09PUZhbHNlXVsicGF5bWVudF9zdGF0dXMiXS5lcSgiTGF0ZS1VbnBhaWQiKS5tZWFuKCkpCiAgICBzdW1tYXJ5WyJsYXRlX3VucGFpZF9pbnN1cmVkX3BjdCJdID0gcm91bmQoMTAwKmxhdGVfdW5wYWlkX2luc3VyZWQsMikKICAgIHN1bW1hcnlbImxhdGVfdW5wYWlkX3VuaW5zdXJlZF9wY3QiXSA9IHJvdW5kKDEwMCpsYXRlX3VucGFpZF91bmluc3VyZWQsMikKCiAgICBsaW5lcyA9IFsiVkFMSURBVElPTiBTVU1NQVJZICh2MTIuNikiXQogICAgZm9yIGssdiBpbiBzdW1tYXJ5Lml0ZW1zKCk6CiAgICAgICAgbGluZXMuYXBwZW5kKGYie2t9OiB7dn0iKQogICAgKFBhdGgob3V0ZGlyKS8idmFsaWRhdGlvbl9yZXBvcnQudHh0Iikud3JpdGVfdGV4dCgiXG4iLmpvaW4obGluZXMpLCBlbmNvZGluZz0idXRmLTgiKQogICAgcHJpbnQoIlxuIi5qb2luKGxpbmVzKSkKICAgIHJldHVybiBzdW1tYXJ5CgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBNYWluCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKZGVmIG1haW4oKToKICAgIGFwID0gYXJncGFyc2UuQXJndW1lbnRQYXJzZXIoKQogICAgYXAuYWRkX2FyZ3VtZW50KCItLXBhdGllbnRzIiwgdHlwZT1pbnQsIGRlZmF1bHQ9NTAwMDApCiAgICBhcC5hZGRfYXJndW1lbnQoIi0tc2VlZCIsIHR5cGU9aW50LCBkZWZhdWx0PTIwMjUwOTE0KQogICAgYXAuYWRkX2FyZ3VtZW50KCItLXRvZGF5IiwgdHlwZT1zdHIsIGRlZmF1bHQ9IjIwMjUtMDktMTQiKQogICAgYXAuYWRkX2FyZ3VtZW50KCItLW91dGRpciIsIHR5cGU9c3RyLCBkZWZhdWx0PSJoZWFsdGhjYXJlX3YxM18yX291dCIpCiAgICBhcC5hZGRfYXJndW1lbnQoIi0tZXhwb3J0LXByZWZpeCIsIHR5cGU9c3RyLCBkZWZhdWx0PSJoZWFsdGhjYXJlX3YxM18yIikKICAgIGFwLmFkZF9hcmd1bWVudCgiLS12YWxpZGF0ZSIsIGFjdGlvbj0ic3RvcmVfdHJ1ZSIpCiAgICBhcC5hZGRfYXJndW1lbnQoIi0tbWlub3Itc2FtZS1kYXktcmF0ZSIsIHR5cGU9ZmxvYXQsIGRlZmF1bHQ9MC40MjUsCiAgICAgICAgICAgICAgICAgICAgaGVscD0iQmFzZSBzYW1lLWRheSBkaXNjaGFyZ2UgcmF0ZSBmb3IgbWlub3IvY2hyb25pYyBjb25kaXRpb25zIChOb3JtYWwvTWlsZCkuIEFkanVzdGVkIGJ5IGhvc3BpdGFsL2RvY3Rvci4iKQogICAgYXJncyA9IGFwLnBhcnNlX2FyZ3MoKQoKICAgIHRvdGFsX3BhdGllbnRzID0gYXJncy5wYXRpZW50cwogICAgc2VlZCA9IGFyZ3Muc2VlZAogICAgdG9kYXkgPSBwZC5UaW1lc3RhbXAoYXJncy50b2RheSkKICAgIG91dGRpciA9IFBhdGgoYXJncy5vdXRkaXIpOyBvdXRkaXIubWtkaXIocGFyZW50cz1UcnVlLCBleGlzdF9vaz1UcnVlKQogICAgZXhwb3J0X3ByZWZpeCA9IGFyZ3MuZXhwb3J0X3ByZWZpeAogICAgYmFzZV9taW5vcl9zYW1lX2RheSA9IGZsb2F0KG5wLmNsaXAoYXJncy5taW5vcl9zYW1lX2RheV9yYXRlLCAwLjAsIDAuOTUpKQoKICAgIHJhbmRvbS5zZWVkKHNlZWQpOyBucC5yYW5kb20uc2VlZChzZWVkKQogICAgZmFrZSA9IEZha2VyKCJlbl9VUyIpCgogICAgSU5TVVJBTkNFX1BST1ZJREVSUyA9IFtmYWtlLmNvbXBhbnkoKSBmb3IgXyBpbiByYW5nZSgxMjAwKV0KICAgIERPQ1MsIEhPU1BTLCBET0NfSE9TUF9NQVAsIEhPU1BfUFJPRklMRVMsIERPQ19QUk9GSUxFUyA9IGJ1aWxkX2RvY3Rvcl9ob3NwaXRhbF9wb29scyhmYWtlLCBzZWVkPXNlZWQpCgogICAgcGF0aWVudHNfYWxsLCB2aXNpdHNfYWxsLCBiaWxsaW5nX2FsbCA9IFtdLCBbXSwgW10KICAgIHZpc2l0X2NvdW50ZXIgPSAxOyBiaWxsaW5nX2NvdW50ZXIgPSAxCgogICAgZm9yIHBpZCBpbiByYW5nZSgxLCB0b3RhbF9wYXRpZW50cysxKToKICAgICAgICBnZW5kZXIgPSBucC5yYW5kb20uY2hvaWNlKFsiTWFsZSIsIkZlbWFsZSJdKQogICAgICAgIHByZWZpeCA9IG5wLnJhbmRvbS5jaG9pY2UoWyIiLCAiTXIuIiwgIk1ycy4iLCAiTXMuIiwgIkRyLiJdLCBwPVswLjI1LDAuMjUsMC4yLDAuMiwwLjFdKQogICAgICAgIGZpcnN0X25hbWUgPSBmYWtlLmZpcnN0X25hbWVfbWFsZSgpIGlmIGdlbmRlcj09Ik1hbGUiIGVsc2UgZmFrZS5maXJzdF9uYW1lX2ZlbWFsZSgpCiAgICAgICAgbGFzdF9uYW1lID0gZmFrZS5sYXN0X25hbWUoKQogICAgICAgIG5hbWUgPSBmIntmaXJzdF9uYW1lfSB7bGFzdF9uYW1lfSIKICAgICAgICBkb2IgPSBmYWtlLmRhdGVfb2ZfYmlydGgobWluaW11bV9hZ2U9MCwgbWF4aW11bV9hZ2U9OTApCiAgICAgICAgcGhvbmUgPSBmIih7cmFuZG9tLnJhbmRpbnQoMjAwLDk5OSl9KSB7cmFuZG9tLnJhbmRpbnQoMjAwLDk5OSl9LXtyYW5kb20ucmFuZGludCgxMDAwLDk5OTkpfSIKICAgICAgICBlbWFpbCA9IGYie2ZpcnN0X25hbWUubG93ZXIoKX17cmFuZG9tLnJhbmRpbnQoMSw5OTkpfS57bGFzdF9uYW1lLmxvd2VyKCl9QHtmYWtlLmZyZWVfZW1haWxfZG9tYWluKCl9IgogICAgICAgIGFkZHJlc3MgPSBmYWtlLnN0cmVldF9hZGRyZXNzKCk7IGNpdHkgPSBmYWtlLmNpdHkoKTsgc3RhdGUgPSBmYWtlLnN0YXRlX2FiYnIoKTsgemlwYyA9IGZha2UuemlwY29kZSgpCiAgICAgICAgYWdlX3RvZGF5ID0gKHRvZGF5IC0gcGQudG9fZGF0ZXRpbWUoZG9iKSkuZGF5cyAvLyAzNjUKICAgICAgICBibG9vZCA9IG5wLnJhbmRvbS5jaG9pY2UoWyJBKyIsIkEtIiwiQisiLCJCLSIsIkFCKyIsIkFCLSIsIk8rIiwiTy0iXSkKICAgICAgICBpbnN1cmVkID0gbnAucmFuZG9tLnJhbmQoKSA8IDAuNzgKICAgICAgICBwcm92aWRlciA9IG5wLnJhbmRvbS5jaG9pY2UoSU5TVVJBTkNFX1BST1ZJREVSUykgaWYgaW5zdXJlZCBlbHNlIE5vbmUKICAgICAgICBwb2xpY3kgPSBzdHIoZmFrZS5yYW5kb21fbnVtYmVyKGRpZ2l0cz05KSkgaWYgaW5zdXJlZCBlbHNlIE5vbmUKCiAgICAgICAgZG9jID0gbnAucmFuZG9tLmNob2ljZShET0NTKTsgaG9zcCA9IHJhbmRvbS5jaG9pY2UoRE9DX0hPU1BfTUFQW2RvY10pCgogICAgICAgIHJuZyA9IG5wLnJhbmRvbS5kZWZhdWx0X3JuZyhzZWVkICsgcGlkKQoKICAgICAgICAjIEZpcnN0IGNvbmRpdGlvbiB3aXRoIHdlaWdodHMgKHJlZHVjZXMgSGVhcnQgZGlzZWFzZSByYXRlKQogICAgICAgIGZpcnN0X2NvbmQgPSB3ZWlnaHRlZF9waWNrX2NvbmRpdGlvbihhZ2VfdG9kYXksIGdlbmRlciwgcm5nKQoKICAgICAgICAjIFZpc2l0cyBkaXN0cmlidXRpb24gKGNvbXBsZXggc2tldyBoaWdoZXIpCiAgICAgICAgaWYgZmlyc3RfY29uZCBpbiBDT01QTEVYX1NFVDoKICAgICAgICAgICAgcHJvYnMgPSBbKDEsMywwLjMwKSwgKDQsNywwLjMwKSwgKDgsMTIsMC4yNSksICgxMywxOCwwLjE1KV0KICAgICAgICBlbHNlOgogICAgICAgICAgICBwcm9icyA9IFsoMSwzLDAuNTIpLCAoNCw3LDAuMjgpLCAoOCwxMiwwLjE1KSwgKDEzLDE4LDAuMDUpXQogICAgICAgIHIgPSBybmcucmFuZG9tKCk7IGFjYz0wLjA7IG5fdmlzaXRzPTEKICAgICAgICBmb3IgbG8saGkscCBpbiBwcm9iczoKICAgICAgICAgICAgYWNjICs9IHAKICAgICAgICAgICAgaWYgciA8PSBhY2M6CiAgICAgICAgICAgICAgICBuX3Zpc2l0cyA9IHJuZy5pbnRlZ2VycyhsbywgaGkrMSk7IGJyZWFrCgogICAgICAgIGFkbWl0X2RhdGVzID0gcGQudG9fZGF0ZXRpbWUoc29ydGVkKFtmYWtlLmRhdGVfYmV0d2Vlbl9kYXRlcygKICAgICAgICAgICAgZGF0ZV9zdGFydD1wZC5UaW1lc3RhbXAoIjIwMjItMDEtMDEiKS50b19weWRhdGV0aW1lKCksCiAgICAgICAgICAgIGRhdGVfZW5kPXRvZGF5LnRvX3B5ZGF0ZXRpbWUoKQogICAgICAgICkgZm9yIF8gaW4gcmFuZ2UoaW50KG5fdmlzaXRzKSldKSkKCiAgICAgICAgeWVhcmx5X2NvdW50cyA9IHt9CiAgICAgICAgaGVhcnRfYnlwYXNzX3VzZWQgPSBGYWxzZQogICAgICAgIGNoaWxkYmlydGhfY291bnQgPSAwCiAgICAgICAgc2VxX2ZpcnN0X2NoYXJnZSA9IHt9CiAgICAgICAgc2VxX3ByZXZfY2hhcmdlID0ge30KICAgICAgICBwcmV2X2NvbmQgPSBOb25lCiAgICAgICAgcHJldl9zZXYgPSAiTm9ybWFsIgogICAgICAgIHBhdGllbnRfY29uZGl0aW9ucyA9IHNldCgpCgogICAgICAgICMgRGlzdGluY3QgY29uZGl0aW9uIGNhcCBwZXIgcGF0aWVudAogICAgICAgIHJjYXAgPSBucC5yYW5kb20ucmFuZCgpCiAgICAgICAgaWYgcmNhcCA8IDAuNTU6CiAgICAgICAgICAgIGRpc3RpbmN0X2NhcCA9IDEKICAgICAgICBlbGlmIHJjYXAgPCAwLjkwOgogICAgICAgICAgICBkaXN0aW5jdF9jYXAgPSAyCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZGlzdGluY3RfY2FwID0gMwoKICAgICAgICBmb3IgaSwgYWQgaW4gZW51bWVyYXRlKGFkbWl0X2RhdGVzKToKICAgICAgICAgICAgYWdlX2F0X3Zpc2l0ID0gKGFkIC0gcGQudG9fZGF0ZXRpbWUoZG9iKSkuZGF5cyAvLyAzNjUKICAgICAgICAgICAgaWYgaSA9PSAwOgogICAgICAgICAgICAgICAgY29uZCA9IGZpcnN0X2NvbmQKICAgICAgICAgICAgICAgIHBhdGllbnRfY29uZGl0aW9ucy5hZGQoY29uZCkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHBfc2FtZSA9IDAuNzUgaWYgcHJldl9zZXYgaW4gWyJTZXZlcmUiLCJNb2RlcmF0ZSJdIGVsc2UgKDAuNSBpZiBwcmV2X3Nldj09Ik1pbGQiIGVsc2UgMC40KQogICAgICAgICAgICAgICAgaWYgbnAucmFuZG9tLnJhbmQoKSA8IHBfc2FtZSBhbmQgcHJldl9jb25kIGlzIG5vdCBOb25lOgogICAgICAgICAgICAgICAgICAgIGNvbmQgPSBwcmV2X2NvbmQKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHBhdGllbnRfY29uZGl0aW9ucykgPj0gZGlzdGluY3RfY2FwIGFuZCBsZW4ocGF0aWVudF9jb25kaXRpb25zKSA+IDA6CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmQgPSB3ZWlnaHRlZF9waWNrX2NvbmRpdGlvbihhZ2VfYXRfdmlzaXQsIGdlbmRlciwgcm5nLCBleGlzdGluZz1wYXRpZW50X2NvbmRpdGlvbnMsIGFsbG93X25ldz1GYWxzZSkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAjIG9wZW4gdG8gbmV3IGFkZGl0aW9uIChidXQgaG9ub3IgY2FwIGFuZCBhZ2UvZ2VuZGVyIHJ1bGVzKQogICAgICAgICAgICAgICAgICAgICAgICBjYW5kID0gd2VpZ2h0ZWRfcGlja19jb25kaXRpb24oYWdlX2F0X3Zpc2l0LCBnZW5kZXIsIHJuZykKICAgICAgICAgICAgICAgICAgICAgICAgaWYgY2FuZCBub3QgaW4gcGF0aWVudF9jb25kaXRpb25zIG9yIGxlbihwYXRpZW50X2NvbmRpdGlvbnMpIDwgZGlzdGluY3RfY2FwOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZCA9IGNhbmQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGllbnRfY29uZGl0aW9ucy5hZGQoY2FuZCkKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmQgPSB3ZWlnaHRlZF9waWNrX2NvbmRpdGlvbihhZ2VfYXRfdmlzaXQsIGdlbmRlciwgcm5nLCBleGlzdGluZz1wYXRpZW50X2NvbmRpdGlvbnMsIGFsbG93X25ldz1GYWxzZSkKCiAgICAgICAgICAgICMgRmx1L1BuZXVtb25pYSBwZXIteWVhciBjYXAKICAgICAgICAgICAgaWYgY29uZCBpbiBbIkZsdSIsIlBuZXVtb25pYSJdOgogICAgICAgICAgICAgICAga2V5ID0gKGNvbmQsIGFkLnllYXIpCiAgICAgICAgICAgICAgICBpZiB5ZWFybHlfY291bnRzLmdldChrZXksMCkgPj0gMzoKICAgICAgICAgICAgICAgICAgICBjaG9pY2VzID0gbGlzdChwYXRpZW50X2NvbmRpdGlvbnMpIGlmIGxlbihwYXRpZW50X2NvbmRpdGlvbnMpPjAgZWxzZSBbYyBmb3IgYyBpbiBDT05EX05BTUVTIGlmIGMgbm90IGluIFsiRmx1IiwiUG5ldW1vbmlhIl1dCiAgICAgICAgICAgICAgICAgICAgY29uZCA9IHJuZy5jaG9pY2UoY2hvaWNlcykKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgeWVhcmx5X2NvdW50c1trZXldID0geWVhcmx5X2NvdW50cy5nZXQoa2V5LDApKzEKCiAgICAgICAgICAgICMgQ2hpbGRiaXJ0aCBjYXAgKOKJpDIgcGVyIHBhdGllbnQpCiAgICAgICAgICAgIGlmIGNvbmQgPT0gIkNoaWxkYmlydGgiIGFuZCBjaGlsZGJpcnRoX2NvdW50ID49IDI6CiAgICAgICAgICAgICAgICBjaG9pY2VzID0gW2MgZm9yIGMgaW4gKGxpc3QocGF0aWVudF9jb25kaXRpb25zKSBpZiBwYXRpZW50X2NvbmRpdGlvbnMgZWxzZSBDT05EX05BTUVTKSBpZiBjICE9ICJDaGlsZGJpcnRoIl0KICAgICAgICAgICAgICAgIGVsaWcgPSBbYyBmb3IgYyBpbiBjaG9pY2VzIGlmIG5vdCAoYWdlX2F0X3Zpc2l0IDwgMTggYW5kIENPTkRJVElPTlNbY11bImFkdWx0X29ubHkiXSldCiAgICAgICAgICAgICAgICBjb25kID0gcm5nLmNob2ljZShlbGlnIGlmIGVsaWcgZWxzZSBbYyBmb3IgYyBpbiBDT05EX05BTUVTIGlmIGMgIT0gIkNoaWxkYmlydGgiXSkKCiAgICAgICAgICAgIG1ldGEgPSBDT05ESVRJT05TW2NvbmRdOyBjYXRlZ29yeSA9IG1ldGFbImNhdGVnb3J5Il0KCiAgICAgICAgICAgIGlzX2ZvbGxvd3VwID0gKGNvbmQgPT0gcHJldl9jb25kKQogICAgICAgICAgICBpZiBjb25kID09ICJDaGlsZGJpcnRoIiBhbmQgbm90IGlzX2ZvbGxvd3VwOgogICAgICAgICAgICAgICAgY2hpbGRiaXJ0aF9jb3VudCArPSAxCgogICAgICAgICAgICBpZiBub3QgaXNfZm9sbG93dXA6CiAgICAgICAgICAgICAgICBkb2MgPSBucC5yYW5kb20uY2hvaWNlKERPQ1MpCiAgICAgICAgICAgICAgICBob3NwID0gcmFuZG9tLmNob2ljZShET0NfSE9TUF9NQVBbZG9jXSkKICAgICAgICAgICAgICAgIGhvc3BfcHJvZiA9IEhPU1BfUFJPRklMRVNbaG9zcF07IGRvY19wcm9mID0gRE9DX1BST0ZJTEVTW2RvY10KICAgICAgICAgICAgICAgIGxvc19sb3csIGxvc19oaWdoID0gbWV0YVsibG9zIl0KICAgICAgICAgICAgICAgIGxvcyA9IGludChucC5yYW5kb20ucmFuZGludChsb3NfbG93LCBsb3NfaGlnaCsxKSkKICAgICAgICAgICAgICAgIGlmIG1ldGFbInNhbWVfZGF5X29rIl0gYW5kIGxvc19sb3cgPT0gMDoKICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZV9taW5vcl9zYW1lX2RheSBpZiBjYXRlZ29yeSBpbiBbIm1pbm9yIiwiY2hyb25pYyJdIGVsc2UgMC4yMAogICAgICAgICAgICAgICAgICAgIHBfc2FtZSA9IG5wLmNsaXAoYmFzZSArIGhvc3BfcHJvZlsic2FtZV9kYXlfYmlhcyJdICsgZG9jX3Byb2ZbInN0eWxlIl0sIDAuMCwgMC45NSkKICAgICAgICAgICAgICAgICAgICBpZiBucC5yYW5kb20ucmFuZCgpIDwgcF9zYW1lOgogICAgICAgICAgICAgICAgICAgICAgICBsb3MgPSAwCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBsb3MgPSAxIGlmIG5wLnJhbmRvbS5yYW5kKCkgPCAwLjg1IGVsc2UgMgoKICAgICAgICAgICAgZGlzID0gYWQgKyBwZC5UaW1lZGVsdGEoZGF5cz1pbnQobG9zKSkKCiAgICAgICAgICAgIHNldl9wcm9nID0gYWRqdXN0X3NldmVyaXR5KGNvbmQsIDAgaWYgbm90IGlzX2ZvbGxvd3VwIGVsc2UgMSwgMiBpZiBpc19mb2xsb3d1cCBlbHNlIDEpCiAgICAgICAgICAgIHNldiA9IHNldl9wcm9nIGlmIHNldl9wcm9nIGlzIG5vdCBOb25lIGVsc2Ugc2V2ZXJpdHlfZnJvbV9sb3MobG9zKQogICAgICAgICAgICBpZiBzZXYgPT0gIlNldmVyZSIgYW5kIGxvcyA9PSAwOgogICAgICAgICAgICAgICAgbG9zID0gMTsgZGlzID0gYWQgKyBwZC5UaW1lZGVsdGEoZGF5cz0xKTsgc2V2ID0gIk1pbGQiCgogICAgICAgICAgICByeF9iaWFzID0gRE9DX1BST0ZJTEVTW2RvY11bInJ4X2JpYXMiXQogICAgICAgICAgICBpZiBjb25kID09ICJDaGlsZGJpcnRoIiBhbmQgaXNfZm9sbG93dXA6CiAgICAgICAgICAgICAgICB0cmVhdG1lbnQgPSBucC5yYW5kb20uY2hvaWNlKFsiUG9zdHBhcnR1bSBDaGVja3VwIiwgIk1vbml0b3JpbmciLCAiTGFjdGF0aW9uIFN1cHBvcnQiXSwgcD1bMC42LCAwLjMsIDAuMV0pCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICB0cmVhdG1lbnQgPSBwaWNrX3RyZWF0bWVudChjb25kLCBpc19maXJzdF92aXNpdD0obm90IGlzX2ZvbGxvd3VwKSwgc2V2ZXJpdHk9c2V2LCBpc19mb2xsb3d1cD1pc19mb2xsb3d1cCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5cGFzc191c2VkPShjb25kPT0iSGVhcnQgZGlzZWFzZSIgYW5kIEZhbHNlKSwgcnhfYmlhcz1yeF9iaWFzKQoKICAgICAgICAgICAgaWYgY29uZCA9PSAiSGVhcnQgZGlzZWFzZSIgYW5kIHRyZWF0bWVudCA9PSAiQnlwYXNzIFN1cmdlcnkiOgogICAgICAgICAgICAgICAgaWYgaGVhcnRfYnlwYXNzX3VzZWQ6CiAgICAgICAgICAgICAgICAgICAgdHJlYXRtZW50ID0gbnAucmFuZG9tLmNob2ljZShbIk1lZGljYXRpb24iLCAiTW9uaXRvcmluZyJdLCBwPVswLjYsMC40XSkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgaGVhcnRfYnlwYXNzX3VzZWQgPSBUcnVlCgogICAgICAgICAgICBtZWRpY2F0aW9uID0gTm9uZTsgZG9zYWdlID0gTm9uZTsgZnJlcSA9IE5vbmUKICAgICAgICAgICAgaWYgdHJlYXRtZW50ID09ICJNZWRpY2F0aW9uIiBvciAiTWVkaWNhdGlvbiIgaW4gc3RyKHRyZWF0bWVudCk6CiAgICAgICAgICAgICAgICB0cmVhdG1lbnQgPSAiTWVkaWNhdGlvbiIKICAgICAgICAgICAgICAgIGNob2ljZXMgPSBNRURJQ0FUSU9OUy5nZXQoY29uZCwgWyJHZW5lcmFsIFByZXNjcmlwdGlvbiJdKQogICAgICAgICAgICAgICAgbWVkaWNhdGlvbiA9IG5wLnJhbmRvbS5jaG9pY2UoY2hvaWNlcykKICAgICAgICAgICAgICAgIGlmICJJbnN1bGluIiBpbiBtZWRpY2F0aW9uOgogICAgICAgICAgICAgICAgICAgIGRvc2FnZSA9IG5wLnJhbmRvbS5jaG9pY2UoWyI1IHVuaXRzIiwgIjEwIHVuaXRzIiwgIjIwIHVuaXRzIl0pCiAgICAgICAgICAgICAgICAgICAgZnJlcSA9IG5wLnJhbmRvbS5jaG9pY2UoWyJvbmNlIGRhaWx5IiwgInR3aWNlIGRhaWx5IiwgImJlZm9yZSBtZWFscyIsICJhdCBiZWR0aW1lIl0pCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGRvc2FnZSA9IG5wLnJhbmRvbS5jaG9pY2UoWyI1bWciLCIxMG1nIiwiMjBtZyIsIjI1bWciLCI1MG1nIiwiMTAwbWciXSkKICAgICAgICAgICAgICAgICAgICBmcmVxID0gbnAucmFuZG9tLmNob2ljZShbIm9uY2UgZGFpbHkiLCJ0d2ljZSBkYWlseSIsImV2ZXJ5IDggaG91cnMiLCJ3aXRoIGZvb2QiLCJhcyBuZWVkZWQiXSkKCiAgICAgICAgICAgIGhvc3BfcHJvZiA9IEhPU1BfUFJPRklMRVNbaG9zcF0KICAgICAgICAgICAgaWYgKGNvbmQgbm90IGluIHNlcV9maXJzdF9jaGFyZ2UpIG9yIChub3QgaXNfZm9sbG93dXApOgogICAgICAgICAgICAgICAgZmlyc3RfY2hhcmdlID0gaW5pdGlhbF9jaGFyZ2UoY29uZCwgaG9zcF9wcm9mWyJjaGFyZ2VfbXVsdCJdKQogICAgICAgICAgICAgICAgc2VxX2ZpcnN0X2NoYXJnZVtjb25kXSA9IGZpcnN0X2NoYXJnZQogICAgICAgICAgICAgICAgc2VxX3ByZXZfY2hhcmdlW2NvbmRdID0gZmlyc3RfY2hhcmdlCiAgICAgICAgICAgICAgICBjaGFyZ2UgPSBmaXJzdF9jaGFyZ2UKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGNoYXJnZSA9IGZvbGxvd3VwX2NoYXJnZShzZXFfcHJldl9jaGFyZ2VbY29uZF0sIGNvbmQsIHNlcV9maXJzdF9jaGFyZ2VbY29uZF0sIGhvc3BfcHJvZlsiY2hhcmdlX211bHQiXSkKICAgICAgICAgICAgICAgIHNlcV9wcmV2X2NoYXJnZVtjb25kXSA9IGNoYXJnZQoKICAgICAgICAgICAgYmlsbGluZ19kYXRlID0gYWQgKyBwZC5UaW1lZGVsdGEoZGF5cz1ucC5yYW5kb20ucmFuZGludCgwLDYpKQoKICAgICAgICAgICAgaW5zdXJlZF9mbGFnID0gcHJvdmlkZXIgaXMgbm90IE5vbmUKICAgICAgICAgICAgaWYgaW5zdXJlZF9mbGFnOgogICAgICAgICAgICAgICAgaWYgbnAucmFuZG9tLnJhbmQoKSA8IDAuMzU6CiAgICAgICAgICAgICAgICAgICAgY292X3JhdGUgPSBucC5yYW5kb20udW5pZm9ybSgwLjQsIDAuNykKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgY292X3JhdGUgPSBucC5yYW5kb20udW5pZm9ybSgwLjYsIDAuOSkKICAgICAgICAgICAgICAgIGluc19jb3YgPSBpbnQoY2hhcmdlICogY292X3JhdGUpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBpbnNfY292ID0gMAogICAgICAgICAgICBwYXRpZW50X3Jlc3AgPSBjaGFyZ2UgLSBpbnNfY292CgogICAgICAgICAgICBpZiBjaGFyZ2UgPj0gMjAwMDA6CiAgICAgICAgICAgICAgICBwX2luY3JlbWVudGFsID0gMC44CiAgICAgICAgICAgIGVsaWYgY2hhcmdlID49IDgwMDA6CiAgICAgICAgICAgICAgICBwX2luY3JlbWVudGFsID0gMC42CiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBwX2luY3JlbWVudGFsID0gMC40CiAgICAgICAgICAgIGlmIG5vdCBpbnN1cmVkX2ZsYWc6CiAgICAgICAgICAgICAgICBwX2luY3JlbWVudGFsID0gbWluKDAuOTUsIHBfaW5jcmVtZW50YWwgKyAwLjE1KQogICAgICAgICAgICBwYXltZW50X3BsYW4gPSAiSW5jcmVtZW50YWwiIGlmIG5wLnJhbmRvbS5yYW5kKCkgPCBwX2luY3JlbWVudGFsIGVsc2UgIkZ1bGwiCiAgICAgICAgICAgIGV4cGVjdGVkX2RhdGUgPSBiaWxsaW5nX2RhdGUgKyBwZC5UaW1lZGVsdGEoZGF5cz0zMCBpZiBwYXltZW50X3BsYW49PSJGdWxsIiBlbHNlIDM2NSkKCiAgICAgICAgICAgIGxhdGVfdW5wYWlkX2Jhc2UsIGxhdGVfcGFpZF9iYXNlID0gQ09ORF9MQVRFX0JBU0UuZ2V0KGNvbmQsICgwLjEwLCAwLjEyKSkKICAgICAgICAgICAgbGF0ZV91bnBhaWRfcHJvYiA9IGxhdGVfdW5wYWlkX2Jhc2UgKiBob3NwX3Byb2ZbImxhdGVfbXVsdCJdICogKDEuNSBpZiBub3QgaW5zdXJlZF9mbGFnIGVsc2UgMC45KQogICAgICAgICAgICBsYXRlX3VucGFpZF9wcm9iID0gZmxvYXQobnAuY2xpcChsYXRlX3VucGFpZF9wcm9iLCAwLjAyLCAwLjY1KSkKICAgICAgICAgICAgcF9wYWlkX29uX3RpbWUgPSAwLjQ1IGlmIGluc3VyZWRfZmxhZyBlbHNlIDAuMzAKICAgICAgICAgICAgcF9sYXRlX3BhaWQgPSBmbG9hdChucC5jbGlwKGxhdGVfcGFpZF9iYXNlLCAwLjA1LCAwLjM1KSkKICAgICAgICAgICAgaWYgKG5vdCBpbnN1cmVkX2ZsYWcpIGFuZCAoY2hhcmdlID4gMTAwMDApOgogICAgICAgICAgICAgICAgcF9sYXRlX3BhaWQgPSBmbG9hdChucC5jbGlwKHBfbGF0ZV9wYWlkICsgMC4xMCwgMC4wNSwgMC41MCkpCiAgICAgICAgICAgICAgICBwX3BhaWRfb25fdGltZSA9IG1heCgwLjA1LCBwX3BhaWRfb25fdGltZSAtIDAuMDUpCiAgICAgICAgICAgIHJlbWFpbmluZyA9IDEuMCAtIChwX3BhaWRfb25fdGltZSArIHBfbGF0ZV9wYWlkKQogICAgICAgICAgICBwX2xhdGVfdW5wYWlkID0gZmxvYXQobnAuY2xpcChsYXRlX3VucGFpZF9wcm9iLCAwLjAyLCBtYXgoMC4wNSwgcmVtYWluaW5nKSkpCiAgICAgICAgICAgIHRvdGFsID0gcF9wYWlkX29uX3RpbWUgKyBwX2xhdGVfcGFpZCArIHBfbGF0ZV91bnBhaWQKICAgICAgICAgICAgcF9wYWlkX29uX3RpbWUgLz0gdG90YWw7IHBfbGF0ZV9wYWlkIC89IHRvdGFsOyBwX2xhdGVfdW5wYWlkIC89IHRvdGFsCgogICAgICAgICAgICByb2xsID0gbnAucmFuZG9tLnJhbmQoKQogICAgICAgICAgICBhY3R1YWxfZGF0ZSA9IHBkLk5hVDsgc3RhdHVzID0gIkluLXByb2dyZXNzIgogICAgICAgICAgICBpZiByb2xsIDwgcF9wYWlkX29uX3RpbWU6CiAgICAgICAgICAgICAgICBhY3R1YWxfZGF0ZSA9IGV4cGVjdGVkX2RhdGUgLSBwZC5UaW1lZGVsdGEoZGF5cz1ucC5yYW5kb20ucmFuZGludCgwLDYpKQogICAgICAgICAgICAgICAgc3RhdHVzID0gIlBhaWQiCiAgICAgICAgICAgIGVsaWYgcm9sbCA8IHBfcGFpZF9vbl90aW1lICsgcF9sYXRlX3BhaWQ6CiAgICAgICAgICAgICAgICBhY3R1YWxfZGF0ZSA9IGV4cGVjdGVkX2RhdGUgKyBwZC5UaW1lZGVsdGEoZGF5cz1ucC5yYW5kb20ucmFuZGludCgxLDEyMCkpCiAgICAgICAgICAgICAgICBzdGF0dXMgPSAiTGF0ZS1QYWlkIgogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgaWYgcGQuVGltZXN0YW1wLnRvZGF5KCkubm9ybWFsaXplKCkgPj0gZXhwZWN0ZWRfZGF0ZToKICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAiTGF0ZS1VbnBhaWQiCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICJJbi1wcm9ncmVzcyIKCiAgICAgICAgICAgIGlmIHBkLm5vdG5hKGFjdHVhbF9kYXRlKSBhbmQgYWN0dWFsX2RhdGUgPiB0b2RheToKICAgICAgICAgICAgICAgIGFjdHVhbF9kYXRlID0gdG9kYXkKCiAgICAgICAgICAgIHZpc2l0c19hbGwuYXBwZW5kKFt2aXNpdF9jb3VudGVyLCBwaWQsIG5hbWUsIHBkLnRvX2RhdGV0aW1lKGRvYikuc3RyZnRpbWUoIiVZLyVtLyVkIiksCiAgICAgICAgICAgICAgICBhZ2VfYXRfdmlzaXQsIGdlbmRlciwgYmxvb2QsIGNvbmQsIHNldiwgdHJlYXRtZW50LAogICAgICAgICAgICAgICAgbWVkaWNhdGlvbiwgZG9zYWdlLCBmcmVxLAogICAgICAgICAgICAgICAgbnAucmFuZG9tLmNob2ljZShbIlBvc2l0aXZlIiwiTmVnYXRpdmUiLCJJbmNvbmNsdXNpdmUiXSksCiAgICAgICAgICAgICAgICBkb2MsIGhvc3AsIG5wLnJhbmRvbS5yYW5kaW50KDEsMjAwMSksCiAgICAgICAgICAgICAgICBhZC5zdHJmdGltZSgiJVkvJW0vJWQiKSwgZGlzLnN0cmZ0aW1lKCIlWS8lbS8lZCIpLAogICAgICAgICAgICAgICAgIlkiIGlmIGNvbmQgaW4gWyJDYW5jZXIiLCJLaWRuZXkgZmFpbHVyZSIsIlN0cm9rZSIsIkhlYXJ0IGRpc2Vhc2UiLCJCcm9rZW4gYm9uZXMiLCJEaWFiZXRlcyIsIkFzdGhtYSIsIkFydGhyaXRpcyJdIG9yIGFnZV9hdF92aXNpdD49NzAgZWxzZSAiTiJdKQoKICAgICAgICAgICAgYmlsbGluZ19hbGwuYXBwZW5kKFtiaWxsaW5nX2NvdW50ZXIsIHZpc2l0X2NvdW50ZXIsIHBpZCwgbmFtZSwgYmlsbGluZ19kYXRlLnN0cmZ0aW1lKCIlWS8lbS8lZCIpLAogICAgICAgICAgICAgICAgY2hhcmdlLCBpbnNfY292LCBwYXRpZW50X3Jlc3AsIHBheW1lbnRfcGxhbiwKICAgICAgICAgICAgICAgIGV4cGVjdGVkX2RhdGUuc3RyZnRpbWUoIiVZLyVtLyVkIiksCiAgICAgICAgICAgICAgICBhY3R1YWxfZGF0ZS5zdHJmdGltZSgiJVkvJW0vJWQiKSBpZiBwZC5ub3RuYShhY3R1YWxfZGF0ZSkgZWxzZSAiIiwgc3RhdHVzXSkKCiAgICAgICAgICAgIHByZXZfY29uZCA9IGNvbmQKICAgICAgICAgICAgcHJldl9zZXYgPSBzZXYKICAgICAgICAgICAgdmlzaXRfY291bnRlciArPSAxOyBiaWxsaW5nX2NvdW50ZXIgKz0gMQoKICAgICAgICBwYXRpZW50c19hbGwuYXBwZW5kKFtwaWQsIGYie3ByZWZpeH0ge2ZpcnN0X25hbWV9Ii5zdHJpcCgpLCBsYXN0X25hbWUsIG5hbWUsCiAgICAgICAgICAgIHBkLnRvX2RhdGV0aW1lKGRvYikuc3RyZnRpbWUoIiVZLyVtLyVkIiksIGFnZV90b2RheSwgZ2VuZGVyLCBwaG9uZSwgZW1haWwsCiAgICAgICAgICAgIGFkZHJlc3MsIGNpdHksIHN0YXRlLCB6aXBjLCBwcm92aWRlciwgcG9saWN5LCBibG9vZF0pCgogICAgcGF0aWVudHMgPSBwZC5EYXRhRnJhbWUocGF0aWVudHNfYWxsLCBjb2x1bW5zPVsKICAgICAgICAicGF0aWVudF9pZCIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJuYW1lIiwiZGF0ZV9vZl9iaXJ0aCIsImFnZSIsImdlbmRlciIsInBob25lX251bWJlciIsImVtYWlsIiwKICAgICAgICAiYWRkcmVzcyIsImNpdHkiLCJzdGF0ZSIsInppcGNvZGUiLCJpbnN1cmFuY2VfcHJvdmlkZXIiLCJpbnN1cmFuY2VfcG9saWN5X251bWJlciIsImJsb29kX3R5cGUiCiAgICBdKQogICAgdmlzaXRzID0gcGQuRGF0YUZyYW1lKHZpc2l0c19hbGwsIGNvbHVtbnM9WwogICAgICAgICJ2aXNpdF9pZCIsInBhdGllbnRfaWQiLCJuYW1lIiwiZGF0ZV9vZl9iaXJ0aCIsImFnZSIsImdlbmRlciIsImJsb29kX3R5cGUiLCJjb25kaXRpb24iLCJzZXZlcml0eSIsCiAgICAgICAgInRyZWF0bWVudCIsIm1lZGljYXRpb24iLCJkb3NhZ2UiLCJmcmVxdWVuY3kiLCJ0ZXN0X3Jlc3VsdHMiLCJkb2N0b3IiLCJob3NwaXRhbCIsInJvb21fbnVtYmVyIiwiZGF0ZV9vZl9hZG1pc3Npb24iLAogICAgICAgICJkYXRlX29mX2Rpc2NoYXJnZSIsImZvbGxvd191cF9yZXF1aXJlZCIKICAgIF0pCiAgICBiaWxsaW5nID0gcGQuRGF0YUZyYW1lKGJpbGxpbmdfYWxsLCBjb2x1bW5zPVsKICAgICAgICAiYmlsbGluZ19pZCIsInZpc2l0X2lkIiwicGF0aWVudF9pZCIsIm5hbWUiLCJiaWxsaW5nX2RhdGUiLCJ0b3RhbF9jaGFyZ2UiLCJpbnN1cmFuY2VfY292ZXJhZ2VfYW1vdW50IiwKICAgICAgICAicGF0aWVudF9yZXNwb25zaWJpbGl0eV9hbW91bnQiLCJwYXltZW50X3BsYW4iLCJleHBlY3RlZF9wYXltZW50X2RhdGUiLCJhY3R1YWxfcGF5bWVudF9kYXRlIiwicGF5bWVudF9zdGF0dXMiCiAgICBdKQoKICAgIHBfcGF0aCA9IFBhdGgob3V0ZGlyKSAvIGYie2V4cG9ydF9wcmVmaXh9X3BhdGllbnRzLmNzdiIKICAgIHZfcGF0aCA9IFBhdGgob3V0ZGlyKSAvIGYie2V4cG9ydF9wcmVmaXh9X3Zpc2l0cy5jc3YiCiAgICBiX3BhdGggPSBQYXRoKG91dGRpcikgLyBmIntleHBvcnRfcHJlZml4fV9iaWxsaW5nLmNzdiIKICAgIHBhdGllbnRzLnRvX2NzdihwX3BhdGgsIGluZGV4PUZhbHNlKQogICAgdmlzaXRzLnRvX2Nzdih2X3BhdGgsIGluZGV4PUZhbHNlKQogICAgYmlsbGluZy50b19jc3YoYl9wYXRoLCBpbmRleD1GYWxzZSkKICAgIHByaW50KGYiRXhwb3J0ZWQ6XFxuIHtwX3BhdGh9XFxuIHt2X3BhdGh9XFxuIHtiX3BhdGh9IikKCiAgICBpZiBhcmdzLnZhbGlkYXRlOgogICAgICAgIHZhbGlkYXRlX3N1bW1hcnkocGF0aWVudHMsIHZpc2l0cywgYmlsbGluZywgYXJncy50b2RheSwgb3V0ZGlyLCBiYXNlX21pbm9yX3NhbWVfZGF5KQoKaWYgX19uYW1lX189PSJfX21haW5fXyI6CiAgICBtYWluKCkK"

def pick_file_by_suffix(folder, suffix):
    cand = sorted(glob.glob(os.path.join(folder, f"*_{suffix}.csv")), key=os.path.getmtime, reverse=True)
    if not cand:
        raise FileNotFoundError(f"No *_{suffix}.csv found in {folder}")
    return cand[0]

def derive(df, *names):
    for n in names:
        if n in df.columns: return n
    return None

# ---------------- Fixes kept ----------------
def fix_ages(visits, patients):
    pid_v = derive(visits, "patient_id","Patient_ID","id")
    pid_p = derive(patients, "id","patient_id","Patient_ID")
    dob_p = derive(patients, "date_of_birth","dob","Date_of_Birth")
    admit = derive(visits, "date_of_admission","admit_date","admission_date")
    age_v = derive(visits, "age","Age")
    if not all([pid_v, pid_p, dob_p, admit, age_v]):
        return visits
    v = visits.merge(patients[[pid_p, dob_p]].rename(columns={pid_p:"__pid__", dob_p:"__dob__"}),
                     left_on=pid_v, right_on="__pid__", how="left")
    v["__ad"] = pd.to_datetime(v[admit], errors="coerce")
    v["__dob__"] = pd.to_datetime(v["__dob__"], errors="coerce")
    mask = v["__ad"].notna() & v["__dob__"].notna()
    v.loc[mask, age_v] = v.loc[mask].apply(
        lambda r: max(0, r["__ad"].year - r["__dob__"].year - ((r["__ad"].month, r["__ad"].day) < (r["__dob__"].month, r["__dob__"].day))), axis=1
    )
    v[age_v] = pd.to_numeric(v[age_v], errors="coerce").fillna(0).astype(int).clip(lower=0)
    v.drop(columns=[c for c in ["__pid__","__dob__","__dob","__ad"] if c in v.columns], inplace=True)
    return v

def rescale_charges_for_escalation(visits, billing):
    admit = derive(visits, "date_of_admission","admit_date","admission_date")
    disch = derive(visits, "date_of_discharge","discharge_date","disch_date")
    kv = derive(visits, "visit_id","medical_record_id","id")
    kb = derive(billing, "visit_id","medical_record_id","id")
    ch = derive(billing, "total_charge","Total_Charge")
    if not all([admit, disch, kv, kb, ch]):
        return billing
    tmp = visits[[kv, admit, disch]].copy()
    tmp["__ad"] = pd.to_datetime(tmp[admit], errors="coerce")
    tmp["__dc"] = pd.to_datetime(tmp[disch], errors="coerce")
    tmp["LOS"] = (tmp["__dc"] - tmp["__ad"]).dt.days.fillna(1).astype(int).clip(lower=1)
    b = billing.merge(tmp[[kv,"LOS"]], left_on=kb, right_on=kv, how="left")
    b[ch] = pd.to_numeric(b[ch], errors="coerce").fillna(87)
    los = b["LOS"].fillna(1).astype(int).clip(lower=1).values
    orig = b[ch].values
    daily = np.maximum(40, np.round(orig / np.maximum(1, los) * 0.85))
    base = np.maximum(20, np.round(orig * 0.10))
    esc = np.zeros_like(orig, dtype=float)
    mask = los > 1
    esc[mask] = (orig[mask] - base[mask] - daily[mask]*los[mask]) * 2.0 / (los[mask]*(los[mask]-1))
    esc = np.maximum(10, np.round(esc))
    new_charge = base + daily*los + esc * (los*(los-1)/2.0)
    new_charge = np.maximum(87, np.round(new_charge)).astype(int)
    b[ch] = new_charge
    resp = derive(billing, "patient_responsibility_amount","patient_responsibility")
    cov  = derive(billing, "insurance_coverage_amount","insurance_coverage")
    if resp and cov:
        covv = pd.to_numeric(b[cov], errors="coerce").fillna(0)
        b[resp] = (b[ch] - covv).clip(lower=0).astype(int)
    billing = billing.drop(columns=[ch], errors="ignore")
    out = b[billing.columns.tolist()].copy()
    out[ch] = b[ch].values
    if resp:
        out[resp] = b[resp].values
    return out

def recompute_patient_age(patients: pd.DataFrame, today_str: str) -> pd.DataFrame:
    age_col = next((c for c in ["age","Age"] if c in patients.columns), None)
    dob_col = next((c for c in ["date_of_birth","dob","Date_of_Birth"] if c in patients.columns), None)
    if not age_col or not dob_col: return patients
    today = pd.to_datetime(today_str, errors="coerce")
    dob = pd.to_datetime(patients[dob_col], errors="coerce")
    had_bday = ((today.month > dob.dt.month) | ((today.month == dob.dt.month) & (today.day >= dob.dt.day)))
    age_calc = (today.year - dob.dt.year - (~had_bday).astype(int)).clip(lower=0)
    mask = dob.notna()
    patients.loc[mask, age_col] = age_calc[mask].astype("Int64").astype(int)
    return patients

# ---------------- ZIP pool & geo helpers ----------------
_PREFIX_STATE = {
    "100":"NY","101":"NY","102":"NY","104":"NY","112":"NY","113":"NY",
    "070":"NJ","073":"NJ","076":"NJ",
    "900":"CA","902":"CA","904":"CA","906":"CA","907":"CA","908":"CA","910":"CA","913":"CA","914":"CA",
    "606":"IL","607":"IL","608":"IL",
    "770":"TX","773":"TX","774":"TX","752":"TX","750":"TX","761":"TX","762":"TX",
    "782":"TX","781":"TX","780":"TX","787":"TX","786":"TX","785":"TX",
    "331":"FL","330":"FL","333":"FL",
    "941":"CA","940":"CA","945":"CA","947":"CA","948":"CA","950":"CA","958":"CA","956":"CA","957":"CA",
    "200":"DC","202":"DC","203":"DC","204":"DC","205":"DC","222":"VA","223":"VA",
    "021":"MA","022":"MA","024":"MA",
    "850":"AZ","852":"AZ","853":"AZ",
    "191":"PA","190":"PA",
    "981":"WA","980":"WA","982":"WA",
    "802":"CO","800":"CO","801":"CO",
    "303":"GA","300":"GA","301":"GA",
    "972":"OR","970":"OR","971":"OR",
    "482":"MI","480":"MI","481":"MI",
    "462":"IN","460":"IN","461":"IN",
    "372":"TN","370":"TN","371":"TN",
    "731":"OK","730":"OK",
    "554":"MN","553":"MN","551":"MN","550":"MN",
    "441":"OH","440":"OH","442":"OH",
    "277":"NC","275":"NC","276":"NC","274":"NC","272":"NC","271":"NC","270":"NC",
    "631":"MO","630":"MO","633":"MO",
    "641":"MO","640":"MO","662":"KS","660":"KS",
    "706":"LA","708":"LA","707":"LA","705":"LA","703":"LA",
    "995":"AK","996":"AK","997":"AK",
}
_PREFIX_CITY = {
    "100":"New York","101":"New York","102":"New York","104":"Bronx","112":"Brooklyn","113":"Queens",
    "070":"Jersey City","073":"Jersey City","076":"Englewood",
    "900":"Los Angeles","902":"Los Angeles","904":"Santa Monica","906":"Whittier","907":"Long Beach","908":"Long Beach","910":"Pasadena","913":"San Fernando","914":"Van Nuys",
    "606":"Chicago","607":"Chicago","608":"Oak Lawn",
    "770":"Houston","773":"Spring","774":"Katy","752":"Dallas","750":"Plano","761":"Fort Worth","762":"Denton",
    "782":"San Antonio","781":"New Braunfels","780":"Laredo","787":"Austin","786":"Round Rock","785":"McAllen",
    "331":"Miami","330":"Hialeah","333":"Fort Lauderdale",
    "941":"San Francisco","940":"San Mateo","945":"Oakland","947":"Berkeley","948":"Richmond","950":"San Jose","958":"Sacramento","956":"Roseville","957":"Davis",
    "200":"Washington","202":"Washington","203":"Washington","204":"Washington","205":"Washington","222":"Arlington","223":"Alexandria",
    "021":"Boston","022":"Boston","024":"Waltham",
    "850":"Phoenix","852":"Tempe","853":"Glendale",
    "191":"Philadelphia","190":"Upper Darby",
    "981":"Seattle","980":"Bellevue","982":"Everett",
    "802":"Denver","800":"Aurora","801":"Littleton",
    "303":"Atlanta","300":"Marietta","301":"Douglasville",
    "972":"Portland","970":"Beaverton","971":"Hillsboro",
    "482":"Detroit","480":"Warren","481":"Ann Arbor",
    "462":"Indianapolis","460":"Noblesville","461":"Plainfield",
    "372":"Nashville","370":"Franklin","371":"Smyrna",
    "731":"Oklahoma City","730":"Edmond",
    "554":"Minneapolis","553":"Minnetonka","551":"Saint Paul","550":"Forest Lake",
    "441":"Cleveland","440":"Mentor","442":"Akron",
    "277":"Durham","275":"Cary","276":"Raleigh","274":"Greensboro","272":"High Point","271":"Winston-Salem","270":"Statesville",
    "631":"Saint Louis","630":"Chesterfield","633":"Saint Charles",
    "641":"Kansas City","640":"Independence","662":"Overland Park","660":"Lawrence",
    "706":"Baton Rouge","708":"Baton Rouge","707":"Prairieville","705":"Lafayette","703":"Houma",
    "995":"Anchorage","996":"Wasilla","997":"Fairbanks",
}

def _load_zip_pool_df(path_or_df):
    if isinstance(path_or_df, pd.DataFrame):
        df = path_or_df.copy()
    else:
        df = pd.read_csv(path_or_df)
    zcol = next((c for c in ["zipcode","zip","postal_code","ZIP","Zipcode"] if c in df.columns), None)
    if not zcol:
        raise ValueError("ZIP pool must include a 'zipcode' (or 'zip'/'postal_code') column")
    df["zipcode"] = df[zcol].astype(str).str.zfill(5)
    pref3 = df["zipcode"].str[:3]
    scol = next((c for c in ["state","state_id","State","STATE"] if c in df.columns), None)
    if scol:
        df["state"] = df[scol].astype(str).str.upper().str[:2]
    else:
        df["state"] = pref3.map(_PREFIX_STATE).fillna("UNK")
    ccol = next((c for c in ["city","City","CITY"] if c in df.columns), None)
    if ccol:
        df["city"] = df[ccol].astype(str)
    else:
        df["city"] = pref3.map(_PREFIX_CITY).fillna("Unknown")
    return df[["zipcode","state","city"]].drop_duplicates()

# ---------------- Assignment helpers ----------------
def _assign_hospital_zipcodes(visits, zip_pool, seed=42):
    rng = np.random.default_rng(seed)
    hosp = derive(visits, "hospital","Hospital","hospital_name","Hospital_Name","facility","Facility")
    if not hosp: return {}
    hospitals = sorted(visits[hosp].dropna().astype(str).unique().tolist())
    if len(zip_pool) < len(hospitals):
        raise ValueError(f"ZIP pool too small: have {len(zip_pool)} ZIPs but {len(hospitals)} hospitals.")
    chosen = zip_pool[:len(hospitals)]
    rng.shuffle(chosen)
    return {h: z for h, z in zip(hospitals, chosen)}

def _assign_patient_zip_from_hospital(patients, visits, hosp_to_zip, zpool_df):
    """
    Set patients.zip to a ZIP near their primary hospital ZIP (same state; prefer same 3-digit prefix).
    Fill patients.city/state if those columns exist. No new columns are added.
    """
    zp = derive(patients, "zipcode","zip","Zipcode","postal_code")
    city_p = derive(patients, "city","City")
    state_p = derive(patients, "state","State","STATE")
    pid_p = derive(patients, "id","patient_id","Patient_ID")
    pid_v = derive(visits, "patient_id","Patient_ID","id")
    hosp  = derive(visits, "hospital","Hospital","hospital_name","Hospital_Name","facility","Facility")
    if not all([zp, pid_p, pid_v, hosp]): 
        return patients

    # primary hospital per patient = mode
    primary = (visits.groupby(pid_v)[hosp]
                    .agg(lambda s: s.mode().iat[0] if not s.mode().empty else s.dropna().iloc[0] if len(s.dropna()) else None))
    mdf = primary.reset_index().rename(columns={pid_v:"__pid__", hosp:"__hosp__"})
    mdf["__hzip__"] = mdf["__hosp__"].map(hosp_to_zip)
    mdf["__hstate__"] = mdf["__hzip__"].astype(str).str[:3].map(_PREFIX_STATE)

    zdf = zpool_df.copy()
    zdf["__zip5__"] = zdf["zipcode"].astype(str).str.zfill(5)
    zdf["__pref3__"] = zdf["__zip5__"].str[:3]

    def pick_near_zip(hzip):
        hzip = str(hzip).zfill(5)
        pref3 = hzip[:3]
        st = _PREFIX_STATE.get(pref3)
        if not st:
            return hzip
        pool_state = zdf[zdf["state"] == st]
        if pool_state.empty:
            return hzip
        same_pref = pool_state[pool_state["__pref3__"] == pref3]
        if not same_pref.empty:
            return same_pref.sample(1)["__zip5__"].iloc[0]
        return pool_state.sample(1)["__zip5__"].iloc[0]

    mdf["__pzip__"] = mdf["__hzip__"].apply(pick_near_zip)
    mdf = mdf.merge(zdf[["__zip5__","city","state"]].rename(columns={"__zip5__":"__pzip__"}), on="__pzip__", how="left")

    out = patients.merge(mdf[["__pid__","__pzip__","city","state"]], left_on=pid_p, right_on="__pid__", how="left")
    out[zp] = out["__pzip__"].fillna(out.get(zp))
    if city_p and "city" in out.columns:
        out[city_p] = out["city"].fillna(out.get(city_p))
    if state_p and "state" in out.columns:
        out[state_p] = out["state"].fillna(out.get(state_p))
    out.drop(columns=[c for c in ["__pid__","__pzip__","city","state"] if c in out.columns], inplace=True)
    return out

def _propagate_patient_zip_to_visits(patients, visits):
    zip_p = derive(patients, "zipcode","zip","Zipcode","postal_code")
    zip_v = derive(visits,   "zipcode","zip","Zipcode","postal_code")
    pid_v = derive(visits,   "patient_id","Patient_ID","id")
    pid_p = derive(patients, "id","patient_id","Patient_ID")
    if not all([zip_p, zip_v, pid_v, pid_p]): return visits
    v = visits.merge(patients[[pid_p, zip_p]].rename(columns={pid_p:"__pid__", zip_p:"__zip__"}),
                     left_on=pid_v, right_on="__pid__", how="left")
    v[zip_v] = v["__zip__"]
    v.drop(columns=[c for c in ["__pid__","__zip__"] if c in v.columns], inplace=True)
    return v


def _assign_patient_zip_and_hospital(patients, visits, hosp_to_zip, zpool_df, seed=42, leak_rate=0.15, min_cap=2, max_cap=4):
    """
    Hybrid realism:
      - Each patient is assigned a random ZIP from the pool (uniform).
      - Primary assignment to hospitals in the SAME 3-digit prefix (local catchment).
      - Limit per-prefix competition: choose from up to [min_cap, max_cap] hospitals in that prefix.
      - Leakage: with probability `leak_rate`, assign to a hospital in the SAME STATE but a different prefix.
      - Fallback: any hospital if state/prefix pools are empty.
    No new patient columns are added; city/state are only filled if they already exist.
    """
    import numpy as np
    rng = np.random.default_rng(seed)

    # Column resolution
    zp_pat = derive(patients, "zipcode","zip","Zipcode","postal_code")
    city_pat = derive(patients, "city","City")
    state_pat = derive(patients, "state","State","STATE")
    pid_pat = derive(patients, "id","patient_id","Patient_ID")
    pid_vis = derive(visits, "patient_id","Patient_ID","id")
    hosp_vis = derive(visits, "hospital","Hospital","hospital_name","Hospital_Name","facility","Facility")
    if not all([zp_pat, pid_pat, pid_vis, hosp_vis]):
        return patients, visits  # nothing to do

    # Hospital ZIP & prefix/state
    import pandas as pd
    hzip_series = pd.Series(hosp_to_zip, name="__hzip__")
    hdf = hzip_series.reset_index()
    hdf.columns = ["__hosp__", "__hzip__"]
    hdf["__hzip5__"] = hdf["__hzip__"].astype(str).str.zfill(5)
    hdf["__pref3__"] = hdf["__hzip5__"].str[:3]
    hdf["__state2__"] = hdf["__pref3__"].map(_PREFIX_STATE).fillna("UNK")

    # ZIP pool
    zdf = zpool_df.copy()
    zdf["__zip5__"] = zdf["zipcode"].astype(str).str.zfill(5)
    zdf["__pref3__"] = zdf["__zip5__"].str[:3]
    zdf["__state2__"] = zdf["state"].fillna(zdf["__pref3__"].map(_PREFIX_STATE)).fillna("UNK")

    # Build lookups
    from collections import defaultdict
    pref_to_hosps_all = defaultdict(list)
    state_to_hosps = defaultdict(list)
    for _, r in hdf.iterrows():
        pref_to_hosps_all[r["__pref3__"]].append(r["__hosp__"])
        state_to_hosps[r["__state2__"]].append(r["__hosp__"])

    # Cap hospitals per prefix (competition limit)
    capped_pref_to_hosps = {}
    for pref, hosps in pref_to_hosps_all.items():
        cap = rng.integers(min_cap, max_cap+1)  # inclusive upper bound
        if len(hosps) <= cap:
            capped_pref_to_hosps[pref] = hosps[:]
        else:
            # random subset for active competition in that prefix
            idx = rng.choice(len(hosps), size=cap, replace=False)
            capped_pref_to_hosps[pref] = [hosps[i] for i in idx]

    # Random ZIPs for patients (uniform over full pool)
    zip_choices = zdf["__zip5__"].sample(n=len(patients), replace=True, random_state=seed).to_numpy()
    p_assign = pd.DataFrame({ "__pid__": patients[pid_pat].values, "__pzip__": zip_choices })
    p_assign = p_assign.merge(zdf[["__zip5__","city","__state2__","__pref3__"]],
                              left_on="__pzip__", right_on="__zip5__", how="left")

    # Hospital chooser with leakage
    all_hospitals = list(hosp_to_zip.keys())
    def choose_hospital(pref3, state2):
        # PRIMARY: same prefix (capped competition set)
        candidates = capped_pref_to_hosps.get(pref3, [])
        if candidates:
            return rng.choice(candidates)
        # SECONDARY: same state (any prefix)
        state_candidates = state_to_hosps.get(state2, [])
        if state_candidates:
            return rng.choice(state_candidates)
        # FINAL fallback
        return rng.choice(all_hospitals) if all_hospitals else None

    p_assign["__hosp__"] = [choose_hospital(pref, st) for pref, st in zip(p_assign["__pref3__"], p_assign["__state2__"])]
    # Enforce patient state == hospital state by resampling ZIP when needed
    hdf_states = hdf.set_index("__hosp__")["__state2__"].to_dict()
    p_assign["__hstate__"] = p_assign["__hosp__"].map(hdf_states)
    mismatch = p_assign["__state2__"] != p_assign["__hstate__"]
    if mismatch.any():
        zips_by_state = zdf.groupby("__state2__")["__zip5__"].apply(list).to_dict()
        hosp_pref = hdf.set_index("__hosp__")["__pref3__"].to_dict()
        new_zips = []
        for pref, hst, hosp in zip(p_assign.loc[mismatch,"__pref3__"], p_assign.loc[mismatch,"__hstate__"], p_assign.loc[mismatch,"__hosp__"]):
            target_pref = hosp_pref.get(hosp)
            cand = zdf[(zdf["__state2__"]==hst) & (zdf["__pref3__"]==target_pref)]["__zip5__"].tolist()
            if not cand:
                cand = zips_by_state.get(hst, [])
            new_zips.append(rng.choice(cand) if cand else None)
        p_assign.loc[mismatch, "__pzip__"] = new_zips
        # refresh derived props after resample
        p_assign = p_assign.drop(columns=[c for c in ["__zip5__","__pref3__","__state2__"] if c in p_assign.columns]) 
        p_assign = p_assign.merge(zdf[["__zip5__","__pref3__","__state2__","city"]], left_on="__pzip__", right_on="__zip5__", how="left")

    # Write into patients (no new columns)
    out_pat = patients.merge(
        p_assign[[c for c in ["__pid__","__pzip__","city","__state2__"] if c in p_assign.columns]],
        left_on=pid_pat, right_on="__pid__", how="left"
    )
    out_pat[zp_pat] = out_pat["__pzip__"].fillna(out_pat.get(zp_pat))
    if city_pat and "city" in out_pat.columns and "city" in out_pat:
        out_pat[city_pat] = out_pat["city"].fillna(out_pat.get(city_pat))
    if state_pat and "__state2__" in out_pat.columns:
        out_pat[state_pat] = out_pat["__state2__"].fillna(out_pat.get(state_pat))
    out_pat.drop(columns=[c for c in ["__pid__","__pzip__","__zip5__","__pref3__","__state2__","city"] if c in out_pat.columns], inplace=True)

    # Enforce chosen hospital across all visits for the patient
    out_vis = visits.merge(p_assign[["__pid__","__hosp__"]], left_on=pid_vis, right_on="__pid__", how="left")
    out_vis[hosp_vis] = out_vis["__hosp__"].fillna(out_vis[hosp_vis])
    out_vis.drop(columns=[c for c in ["__pid__","__hosp__"] if c in out_vis.columns], inplace=True)

    return out_pat, out_vis


# ---------------- Validation ----------------

def validate_summary(patients, visits, billing, today_str=None):
    def col(df, *names):
        for n in names:
            if n in df.columns: return n
        return None
    import numpy as np
    today = pd.to_datetime(today_str) if today_str else pd.Timestamp.today()

    # Column name resolution
    pid_p = col(patients, "id","patient_id","Patient_ID")
    pid_v = col(visits, "patient_id","Patient_ID","id")
    vid_v = col(visits, "visit_id","medical_record_id","id")
    bid_b = col(billing, "billing_id","Billing_ID","id")
    vid_b = col(billing, "visit_id","medical_record_id","id")
    # demographics
    dob_p = col(patients, "date_of_birth","dob","Date_of_Birth")
    age_p = col(patients, "age","Age")
    dob_v = col(visits, "date_of_birth","dob","Date_of_Birth")
    age_v = col(visits, "age","Age")
    gender_v = col(visits, "gender","Gender","sex","Sex")
    blood_p = col(patients, "blood_type","Blood_Type","blood","Blood")
    blood_v = col(visits, "blood_type","Blood_Type","blood","Blood")
    # clinical
    cond_v = col(visits, "condition","Condition","diagnosis","Diagnosis")
    treat_v = col(visits, "treatment","Treatment","procedure","Procedure")
    severity_v = col(visits, "severity","Severity")
    # dates
    admit = col(visits, "date_of_admission","admission_date","admit_date")
    disch = col(visits, "date_of_discharge","discharge_date","disch_date")
    # insurance / billing
    # insurance / billing
    insurer_p = col(patients, "insurance_provider","Insurance_Provider","insurer")
    policy_p  = col(patients, "policy_number","Policy_Number","policy", "insurance_policy_number","Insurance_Policy_Number","insurancePolicyNumber")
    insurer_v = col(visits, "insurance_provider","Insurance_Provider","insurer")
    policy_v  = col(visits, "policy_number","Policy_Number","policy", "insurance_policy_number","Insurance_Policy_Number","insurancePolicyNumber")
    total_b = col(billing, "total_charge","Total_Charge")
    expected_b = col(billing, "expected_payment_date","Expected_Payment_Date")
    actual_b   = col(billing, "actual_payment_date","Actual_Payment_Date")
    status_b   = col(billing, "payment_status","Payment_Status","status")
    # hospital / geo
    hosp_v = col(visits, "hospital","Hospital","hospital_name","Hospital_Name","facility","Facility")
    hz = "hospital_zipcode" if "hospital_zipcode" in visits.columns else None
    hs = "hospital_state" if "hospital_state" in visits.columns else None
    zipcode_p = col(patients, "zipcode","zip","Zipcode","postal_code")
    city_p = col(patients, "city","City")
    state_p = col(patients, "state","State","STATE")

    summary = {}

    # ---------- Structural & Linkage ----------
    summary["patients_unique_ids"] = int(patients[pid_p].nunique() == len(patients)) if pid_p else -1
    summary["visits_unique_ids"]   = int(visits[vid_v].nunique() == len(visits)) if vid_v else -1
    summary["billing_unique_ids"]  = int(billing[bid_b].nunique() == len(billing)) if bid_b else -1

    summary["patients_rows"] = int(len(patients))
    summary["visits_rows"]   = int(len(visits))
    summary["billing_rows"]  = int(len(billing))

    if vid_b and vid_v:
        counts = billing.groupby(vid_b).size()
        summary["visits_missing_billing"] = int((~visits[vid_v].isin(counts.index)).sum())
        summary["multiple_billings_per_visit"] = int((counts > 1).sum())
    else:
        summary["visits_missing_billing"] = -1
        summary["multiple_billings_per_visit"] = -1

    # ---------- Demographics & Age Consistency ----------
    if dob_p and age_p:
        ap = patients.copy()
        ap["_dob"] = pd.to_datetime(ap[dob_p], errors="coerce")
        had_bday = ((today.month > ap["_dob"].dt.month) | ((today.month == ap["_dob"].dt.month) & (today.day >= ap["_dob"].dt.day)))
        ap["_age_calc"] = (today.year - ap["_dob"].dt.year - (~had_bday).astype(int)).clip(lower=0)
        summary["patient_age_mismatches"] = int((pd.to_numeric(ap[age_p], errors="coerce").fillna(-1).astype(int) != ap["_age_calc"].fillna(-1).astype(int)).sum())
    else:
        summary["patient_age_mismatches"] = -1

    if dob_v and age_v and admit:
        vv = visits.copy()
        vv["_dob"] = pd.to_datetime(vv[dob_v], errors="coerce")
        vv["_ad"]  = pd.to_datetime(vv[admit], errors="coerce")
        had_bday = ((vv["_ad"].dt.month > vv["_dob"].dt.month) | ((vv["_ad"].dt.month == vv["_dob"].dt.month) & (vv["_ad"].dt.day >= vv["_dob"].dt.day)))
        vv["_age_calc"] = (vv["_ad"].dt.year - vv["_dob"].dt.year - (~had_bday).astype(int)).clip(lower=0)
        summary["visit_age_mismatches"] = int((pd.to_numeric(vv[age_v], errors="coerce").fillna(-1).astype(int) != vv["_age_calc"].fillna(-1).astype(int)).sum())
    else:
        summary["visit_age_mismatches"] = -1

    if blood_v and pid_v:
        by_p = visits.groupby(pid_v)[blood_v].nunique(dropna=True)
        summary["blood_type_inconsistencies"] = int((by_p > 1).sum())
    elif blood_p and pid_p:
        by_p = patients.groupby(pid_p)[blood_p].nunique(dropna=True)
        summary["blood_type_inconsistencies"] = int((by_p > 1).sum())
    else:
        summary["blood_type_inconsistencies"] = -1

    # ---------- Insurance Integrity ----------
    # policy present but provider null (patients or visits; sum both if both exist)
    def _policy_without_provider(df, policy_col, prov_col):
        if not policy_col or not prov_col: return 0
        return int(((df[policy_col].astype(str).str.strip() != "") & (df[prov_col].isna() | (df[prov_col].astype(str).str.strip()==""))).sum())
    summary["policy_without_provider"] = (
        (_policy_without_provider(patients, policy_p, insurer_p) if policy_p and insurer_p else 0) +
        (_policy_without_provider(visits, policy_v, insurer_v) if policy_v and insurer_v else 0)
        if (policy_p or policy_v) else -1
    )

    # ---------- Clinical Gating & Special Rules ----------
    # childbirth rules require condition + gender + age
    def _is_childbirth(x):
        if not isinstance(x, str): return False
        return "childbirth" in x.lower() or "labor" in x.lower() or "delivery" in x.lower()
    if cond_v and gender_v:
        is_cb = visits[cond_v].apply(_is_childbirth)
        if gender_v:
            summary["childbirth_non_female"] = int((is_cb & (~visits[gender_v].astype(str).str.lower().isin(["female","f"])) ).sum())
        else:
            summary["childbirth_non_female"] = -1
        if age_v:
            summary["childbirth_age_out_of_range"] = int((is_cb & ~visits[age_v].between(16,55, inclusive="both")).sum())
        else:
            summary["childbirth_age_out_of_range"] = -1
    else:
        summary["childbirth_non_female"] = -1
        summary["childbirth_age_out_of_range"] = -1

    # ---------- Condition Breadth & Frequency Limits ----------
    if cond_v and pid_v:
        nconds = visits.groupby(pid_v)[cond_v].nunique(dropna=True)
        summary["patients_with_gt3_conditions"] = int((nconds > 3).sum())
    else:
        summary["patients_with_gt3_conditions"] = -1

    if cond_v and treat_v:
        is_hd = visits[cond_v].astype(str).str.lower().str.contains("heart")
        is_bypass = visits[treat_v].astype(str).str.lower().str.contains("bypass")
        by_pt = visits[is_hd & is_bypass].groupby(pid_v).size() if pid_v else pd.Series(dtype=int)
        summary["heart_bypass_gt1_violations"] = int((by_pt > 1).sum()) if not by_pt.empty else -1
    else:
        summary["heart_bypass_gt1_violations"] = -1

    if cond_v and pid_v:
        is_cb = visits[cond_v].apply(_is_childbirth)
        per_pt = is_cb.groupby(visits[pid_v]).sum()
        summary["childbirth_visits_per_patient_gt2"] = int((per_pt > 2).sum()) if not per_pt.empty else -1
    else:
        summary["childbirth_visits_per_patient_gt2"] = -1

    if cond_v and treat_v:
        is_cb = visits[cond_v].apply(_is_childbirth)
        allowed = {"postpartum checkup","monitoring","lactation support","postpartum monitoring"}
        bad = (is_cb & (~visits[treat_v].astype(str).str.lower().isin(allowed)))
        summary["childbirth_followup_treatment_violations"] = int(bad.sum())
    else:
        summary["childbirth_followup_treatment_violations"] = -1

    # ---------- LOS & Same-Day Discharges ----------
    if admit and disch:
        vv = visits[[hosp_v, severity_v, cond_v, admit, disch]].copy()
        vv["_ad"] = pd.to_datetime(vv[admit], errors="coerce")
        vv["_dc"] = pd.to_datetime(vv[disch], errors="coerce")
        vv["_los_days"] = (vv["_dc"] - vv["_ad"]).dt.days
        same_day = (vv["_los_days"] == 0)
        # Minor/Chronic + Normal/Mild if columns exist
        mask_minor = vv[cond_v].astype(str).str.lower().str.contains("minor|chronic") if cond_v else False
        mask_sev = vv[severity_v].astype(str).str.lower().isin(["normal","mild"]) if severity_v else True
        denom = (mask_sev) if isinstance(mask_sev, (pd.Series, np.ndarray)) else same_day.index == same_day.index
        rate = (same_day[denom].mean()*100) if denom is not False and denom is not True else (same_day.mean()*100)
        summary["minor_same_day_rate_actual_pct"] = round(float(rate), 2) if not np.isnan(rate) else -1.0
        by_h = same_day.groupby(vv[hosp_v]).mean()*100 if hosp_v else pd.Series(dtype=float)
        summary["same_day_rate_by_hospital_stddev_pct"] = float(by_h.std()) if not by_h.empty else -1.0
        summary["same_day_rate_top_hospital_pct"] = float(by_h.max()) if not by_h.empty else -1.0
        summary["same_day_rate_overall_pct"] = round(float(same_day.mean()*100), 2) if same_day.notna().any() else -1.0
    else:
        summary["minor_same_day_rate_actual_pct"] = -1.0
        summary["same_day_rate_by_hospital_stddev_pct"] = -1.0
        summary["same_day_rate_top_hospital_pct"] = -1.0
        summary["same_day_rate_overall_pct"] = -1.0

    # ---------- Billing Trend & Payment Logic ----------
    if total_b and admit and pid_v and cond_v and vid_v and vid_b:
        tmp = visits[[pid_v, cond_v, admit, vid_v]].copy()
        bsub = billing[[vid_b, total_b]].rename(columns={vid_b:"__vid__"})
        tmp = tmp.merge(bsub, left_on=vid_v, right_on="__vid__", how="left")
        tmp[admit] = pd.to_datetime(tmp[admit], errors="coerce")
        tmp[total_b] = pd.to_numeric(tmp[total_b], errors="coerce")
        counts_inc = 0
        counts_all = 0
        runs_nondec = 0
        exceeded_first = 0
        for (pt, cd), grp in tmp.groupby([pid_v, cond_v]):
            g = grp.sort_values(by=admit)
            charges = g[total_b].dropna().values
            if len(charges) >= 2:
                counts_all += (len(charges)-1)
                incs = (charges[1:] > charges[:-1]).sum()
                counts_inc += int(incs)
                exceeded_first += int((charges[1:] > charges[:1]).sum())
                if np.all(charges[1:] >= charges[:-1]):
                    runs_nondec += 1
        summary["billing_followup_exceeded_first"] = int(exceeded_first)
        pct_inc = (counts_inc / counts_all * 100.0) if counts_all else 0.0
        summary["billing_followup_increase_pct"] = round(float(pct_inc), 2)
        summary["billing_overall_upward_trend_runs"] = int(runs_nondec)
    else:
        summary["billing_followup_exceeded_first"] = -1
        summary["billing_followup_increase_pct"] = -1.0
        summary["billing_overall_upward_trend_runs"] = -1

    # ---------- Payment Sanity & Dates ----------
    if actual_b:
        ap = pd.to_datetime(billing[actual_b], errors="coerce")
        summary["payment_future_dates"] = int((ap > today).sum())
    else:
        summary["payment_future_dates"] = -1

    # Payment status rules & insured vs outcomes
    def _is_late_unpaid(row):
        exp = pd.to_datetime(row.get(expected_b), errors="coerce") if expected_b else pd.NaT
        act = pd.to_datetime(row.get(actual_b), errors="coerce") if actual_b else pd.NaT
        if pd.isna(exp) and pd.isna(act): 
            return False
        if pd.isna(act):  # unpaid
            return (not pd.isna(exp)) and (exp < today)
        return (not pd.isna(exp)) and (act > exp)  # paid late
    if expected_b and (actual_b or status_b):
        btmp = billing.copy()
        btmp["_late_unpaid"] = btmp.apply(_is_late_unpaid, axis=1)
        # Determine insured: prefer visits/patients provider presence
        if insurer_v and vid_b and vid_v:
            vmap = visits[[vid_v, insurer_v]].rename(columns={vid_v:"__vid", insurer_v:"__prov"})
            btmp = btmp.merge(vmap, left_on=vid_b, right_on="__vid", how="left")
            insured = ~(btmp["__prov"].isna() | (btmp["__prov"].astype(str).str.strip()==""))
        elif insurer_p and pid_v and vid_b and vid_v and pid_p:
            v2 = visits[[vid_v, pid_v]].rename(columns={vid_v:"__vid", pid_v:"__pid"})
            p2 = patients[[pid_p, insurer_p]].rename(columns={pid_p:"__pid", insurer_p:"__prov"})
            btmp = btmp.merge(v2, left_on=vid_b, right_on="__vid", how="left").merge(p2, on="__pid", how="left")
            insured = ~(btmp["__prov"].isna() | (btmp["__prov"].astype(str).str.strip()==""))
        else:
            insured = pd.Series(False, index=btmp.index)
        if insured.any():
            summary["late_unpaid_insured_pct"] = round(float(btmp.loc[insured, "_late_unpaid"].mean()*100), 2)
        else:
            summary["late_unpaid_insured_pct"] = -1.0
        if (~insured).any():
            summary["late_unpaid_uninsured_pct"] = round(float(btmp.loc[~insured, "_late_unpaid"].mean()*100), 2)
        else:
            summary["late_unpaid_uninsured_pct"] = -1.0
    else:
        summary["late_unpaid_insured_pct"] = -1.0
        summary["late_unpaid_uninsured_pct"] = -1.0

    # ---------- Existing geo/charge checks ----------
    if total_b:
        summary["charges_below_87"] = int((pd.to_numeric(billing[total_b], errors="coerce") < 87).sum())
        summary["zero_charges"] = int((pd.to_numeric(billing[total_b], errors="coerce") <= 0).sum())
    else:
        summary["charges_below_87"] = -1
        summary["zero_charges"] = -1

    # hospital one-zip & state match
    if hosp_v and hz:
        grp = visits.groupby(hosp_v)[hz].nunique(dropna=True)
        summary["hospitals_with_multiple_zipcodes"] = int((grp > 1).sum())
        summary["hospital_zipcodes_unique"] = int((grp > 1).sum() == 0)
    else:
        summary["hospitals_with_multiple_zipcodes"] = -1
        summary["hospital_zipcodes_unique"] = -1

    if hz and hs:
        inferred = visits[hz].astype(str).str[:3].map(_PREFIX_STATE)
        summary["hospital_state_mismatch"] = int(((visits[hs].fillna("UNK")) != (inferred.fillna("UNK"))).sum())
    else:
        summary["hospital_state_mismatch"] = -1

    # patient vs hospital state
    if pid_v and pid_p and zipcode_p and hs:
        vv = visits[[pid_v, hs]].copy()
        pp = patients[[pid_p, zipcode_p]].copy()
        merged = vv.merge(pp, left_on=pid_v, right_on=pid_p, how="left")
        p_state = merged[zipcode_p].astype(str).str[:3].map(_PREFIX_STATE)
        summary["patient_state_differs_from_hospital_state"] = int(((p_state.fillna("UNK")) != (merged[hs].fillna("UNK"))).sum())
    else:
        summary["patient_state_differs_from_hospital_state"] = -1

    # patient city presence (if column exists)
    if city_p:
        summary["patients_city_missing"] = int(patients[city_p].isna().sum() + (patients[city_p].astype(str).str.strip() == "").sum())
    else:
        summary["patients_city_missing"] = -1

    summary["version"] = "VALIDATION SUMMARY (v13.10  full checks)"
    return summary

# ---------------- Main ----------------
def main(argv=None):
    parser = argparse.ArgumentParser(description="Healthcare Dataset Generator v13_10 (standalone)")
    parser.add_argument("--patients", type=int, default=1000)
    parser.add_argument("--seed", type=int, default=42)
    parser.add_argument("--today", type=str, default="2025-10-14")
    parser.add_argument("--outdir", type=str, default=".")
    parser.add_argument("--zip-target", type=int, default=120, help="Target count of distinct ZIP codes (max based on pool).")
    parser.add_argument("--zip-pool-file", type=str, default="", help="CSV/TXT file with columns: zipcode (required), state (preferred), city (preferred).")
    args, unknown = parser.parse_known_args(argv)

    # Run embedded base v13_2
    tmp_dir = tempfile.mkdtemp(prefix="v132_embed_")
    base_path = os.path.join(tmp_dir, "base_v13_2.py")
    with open(base_path, "wb") as f:
        f.write(base64.b64decode(BASE_B64.encode("ascii")))
    cmd = ["python", base_path, "--patients", str(args.patients), "--seed", str(args.seed), "--today", args.today, "--outdir", tmp_dir] + unknown
    proc = subprocess.run(cmd, capture_output=True, text=True)
    if proc.returncode != 0:
        raise RuntimeError(f"Embedded base failed: {proc.stderr[:600]}")

    patients_csv = pick_file_by_suffix(tmp_dir, "patients")
    visits_csv   = pick_file_by_suffix(tmp_dir, "visits")
    billing_csv  = pick_file_by_suffix(tmp_dir, "billing")
    patients = pd.read_csv(patients_csv)
    visits   = pd.read_csv(visits_csv)
    billing  = pd.read_csv(billing_csv)
    ## HOSPITAL CANONICALIZATION
    hosp_col = derive(visits, 'hospital','Hospital','hospital_name','Hospital_Name','facility','Facility')
    if hosp_col:
        visits[hosp_col] = (visits[hosp_col].astype(str).str.strip()
                             .str.replace(r'\s+',' ', regex=True).str.title())

    # Enforce one-hospital-per-patient (primary = mode)
    hosp_col = derive(visits, "hospital","Hospital","hospital_name","Hospital_Name","facility","Facility")
    pid_v = derive(visits, "patient_id","Patient_ID","id")
    if hosp_col and pid_v:
        primary = (visits.groupby(pid_v)[hosp_col]
                        .agg(lambda s: s.mode().iat[0] if not s.mode().empty else s.dropna().iloc[0] if len(s.dropna()) else None))
        primary = primary.reset_index().rename(columns={pid_v:"__pid__", hosp_col:"__h__"})
        visits = visits.merge(primary, left_on=pid_v, right_on="__pid__", how="left")
        visits[hosp_col] = visits["__h__"]
        visits.drop(columns=[c for c in ["__pid__","__h__"] if c in visits.columns], inplace=True)

    # Post-gen fixes
    visits = fix_ages(visits, patients)
    billing = rescale_charges_for_escalation(visits, billing)

    # Build ZIP pool dataframe and trim to target
    if args.zip_pool_file and os.path.exists(args.zip_pool_file):
        _zdf = _load_zip_pool_df(args.zip_pool_file)
    else:
        _zdf = _load_zip_pool_df(pd.DataFrame({"zipcode": list(_PREFIX_STATE.keys())}))
    _zip_to_state = dict(zip(_zdf["zipcode"], _zdf["state"]))
    zip_pool_full = _zdf["zipcode"].tolist()  # use full pool for hospitals to guarantee uniqueness
    zip_pool = _zdf["zipcode"].tolist()[:max(args.zip_target, _zdf.shape[0])]

    # Assign UNIQUE ZIP per hospital (stratified across states, unique per hospital)
    if args.zip_pool_file and os.path.exists(args.zip_pool_file):
        _zdf = _load_zip_pool_df(args.zip_pool_file)
    else:
        _zdf = _load_zip_pool_df(pd.DataFrame({'zipcode': list(_PREFIX_STATE.keys())}))
    _zdf['zipcode'] = _zdf['zipcode'].astype(str).str.zfill(5)
    _zdf['state'] = _zdf['state'].astype(str).str.upper().str[:2]

    hosp_col = derive(visits, 'hospital','Hospital','hospital_name','Hospital_Name','facility','Facility')
    hospitals = sorted(visits[hosp_col].dropna().astype(str).unique().tolist()) if hosp_col else []

    rng = np.random.default_rng(args.seed)
    # proportional allocation by state
    vc = _zdf['state'].value_counts()
    tot = int(vc.sum()) if len(vc) else 1
    alloc = {st: int(round(len(hospitals) * (cnt/tot))) for st, cnt in vc.items()}
    delta = len(hospitals) - sum(alloc.values())
    states = list(vc.index)
    i=0
    while delta != 0 and states:
        st = states[i % len(states)]
        if delta > 0:
            alloc[st] += 1; delta -= 1
        else:
            if alloc[st] > 0:
                alloc[st] -= 1; delta += 1
        i += 1

    chosen = []
    for st, n in alloc.items():
        if n <= 0: continue
        pool = _zdf.loc[_zdf['state']==st, 'zipcode'].unique()
        if len(pool) >= n:
            chosen.extend(rng.choice(pool, size=n, replace=False).tolist())
        else:
            chosen.extend(pool.tolist())
    short = len(hospitals) - len(chosen)
    if short > 0:
        remaining = np.setdiff1d(_zdf['zipcode'].unique(), chosen)
        chosen.extend(rng.choice(remaining, size=short, replace=False).tolist())
    rng.shuffle(chosen)
    hosp_to_zip = {h:z for h,z in zip(hospitals, chosen)}
    _zip_to_state = dict(zip(_zdf['zipcode'], _zdf['state']))

    if hosp_col:
        visits["hospital_zipcode"] = visits[hosp_col].map(hosp_to_zip)
        visits["hospital_state"] = visits["hospital_zipcode"].map(_zip_to_state).fillna(
            visits["hospital_zipcode"].astype(str).str[:3].map(_PREFIX_STATE)
        ).fillna("UNK")

    # patients: enforce same-state & near-prefix ZIP, fill city/state if columns exist
    patients, visits = _assign_patient_zip_and_hospital(patients, visits, hosp_to_zip, _zdf, seed=args.seed)
    # Rebuild hospital->ZIP mapping *from patient ZIPs* to avoid state skew.
    if hosp_col:
        # Build patient ZIP prefix/state maps
        zipcol_pat = derive(patients, "zipcode","zip","Zipcode","postal_code")
        vp = derive(visits, "patient_id","Patient_ID","id")
        pp = derive(patients, "id","patient_id","Patient_ID")
        if zipcol_pat and vp and pp:
            vpp = visits[[vp, hosp_col]].copy()
            pz  = patients[[pp, zipcol_pat]].copy()
            m   = vpp.merge(pz, left_on=vp, right_on=pp, how="left")
            m["__zip5__"] = m[zipcol_pat].astype(str).str.zfill(5)
            m["__pref3__"] = m["__zip5__"].str[:3]
            # Infer state from pool or prefix
            _zdf2 = _zdf.copy()
            _zdf2["zipcode"] = _zdf2["zipcode"].astype(str).str.zfill(5)
            _zdf2["state"] = _zdf2["state"].astype(str).str.upper().str[:2]
            _zip_to_state = dict(zip(_zdf2["zipcode"], _zdf2["state"]))
            m["__state2__"] = m["__zip5__"].map(_zip_to_state).fillna(m["__pref3__"].map(_PREFIX_STATE)).fillna("UNK")

            # For each hospital, select a representative ZIP:
            # 1) Use the modal 3-digit prefix among its patients;
            # 2) Choose a ZIP from the pool in that prefix (same state);
            # 3) Ensure uniqueness across hospitals; if collision, pick another ZIP in same prefix/state; else same state; else anywhere.
            rng = np.random.default_rng(args.seed)
            hosp_list = sorted(visits[hosp_col].dropna().astype(str).unique().tolist())
            hosp_to_zip_new = {}
            used = set()
            for h in hosp_list:
                hh = m[m[hosp_col] == h]
                if hh.empty:
                    continue
                pref_counts = hh["__pref3__"].value_counts()
                pick_zip = None
                for pref in pref_counts.index.tolist():
                    st = _PREFIX_STATE.get(pref, None)
                    # Candidate zips in pool: same pref (and state if available)
                    cand = _zdf2.loc[_zdf2["zipcode"].str[:3]==pref, "zipcode"].tolist()
                    rng.shuffle(cand)
                    # pick a not-yet-used
                    for z in cand:
                        if z not in used:
                            pick_zip = z
                            break
                    if pick_zip: break
                # Fallbacks
                if pick_zip is None:
                    # try same state as patient's majority state
                    st_counts = hh["__state2__"].value_counts()
                    for st in st_counts.index.tolist():
                        cand = _zdf2.loc[_zdf2["state"]==st, "zipcode"].tolist()
                        rng.shuffle(cand)
                        for z in cand:
                            if z not in used:
                                pick_zip = z; break
                        if pick_zip: break
                if pick_zip is None:
                    # anywhere
                    cand = _zdf2["zipcode"].tolist()
                    rng.shuffle(cand)
                    for z in cand:
                        if z not in used:
                            pick_zip = z; break
                hosp_to_zip_new[h] = pick_zip
                used.add(pick_zip)

            hosp_to_zip = hosp_to_zip_new
            _zip_to_state = dict(zip(_zdf2["zipcode"], _zdf2["state"]))
            # Overwrite visits with the rebuilt mapping
            visits["hospital_zipcode"] = visits[hosp_col].map(hosp_to_zip)
            visits["hospital_state"] = visits["hospital_zipcode"].map(_zip_to_state).fillna(
                visits["hospital_zipcode"].astype(str).str[:3].map(_PREFIX_STATE)
            ).fillna("UNK")


    # propagate patient ZIP to visits if visits has zipcode column
    visits = _propagate_patient_zip_to_visits(patients, visits)

    # recompute patient age from DOB using --today
    patients = recompute_patient_age(patients, today_str=args.today)

    # Save outputs
    os.makedirs(args.outdir, exist_ok=True)
    # Cleanup merge artifacts per user spec
    if 'city_x' in patients.columns:
        patients.drop(columns=['city_x'], inplace=True)
    if 'city_y' in patients.columns:
        if 'city' in patients.columns:
            patients['city'] = patients['city'].fillna(patients['city_y'])
            patients.drop(columns=['city_y'], inplace=True)
        else:
            patients.rename(columns={'city_y': 'city'}, inplace=True)

    # --- FINAL REORDER/DROP BEFORE EXPORT ---
    # Patients: place 'city' immediately after 'address' (if both exist)
    if {'address', 'city'}.issubset(patients.columns):
        _pcols = list(patients.columns)
        _city = _pcols.pop(_pcols.index('city'))
        _pcols.insert(_pcols.index('address') + 1, _city)
        patients = patients[_pcols]

    # Visits: drop 'blood_type' and reorder columns
    if 'blood_type' in visits.columns:
        visits.drop(columns=['blood_type'], inplace=True)
    # place 'hospital_state' immediately after 'hospital'
    if {'hospital', 'hospital_state'}.issubset(visits.columns):
        _vcols = list(visits.columns)
        _hstate = _vcols.pop(_vcols.index('hospital_state'))
        _vcols.insert(_vcols.index('hospital') + 1, _hstate)
        visits = visits[_vcols]
    # place 'hospital_zipcode' immediately after 'hospital_state'
    if {'hospital_state', 'hospital_zipcode'}.issubset(visits.columns):
        _vcols = list(visits.columns)
        _hzip = _vcols.pop(_vcols.index('hospital_zipcode'))
        _vcols.insert(_vcols.index('hospital_state') + 1, _hzip)
        visits = visits[_vcols]

    
    # Export once
    patients.to_csv(os.path.join(args.outdir, "patients.csv"), index=False)
    visits.to_csv(os.path.join(args.outdir, "visits.csv"), index=False)
    billing.to_csv(os.path.join(args.outdir, "billing.csv"), index=False)

    
    # --- FINAL STEP (auto): Remove 'name' column from billing export ---
    try:
        import pandas as _pd_final_billname
        _b_path = os.path.join(args.outdir, f"{export_prefix}_billing.csv") if 'export_prefix' in locals() else os.path.join(args.outdir, "billing.csv")
        _bdf = _pd_final_billname.read_csv(_b_path)
        if 'name' in _bdf.columns:
            _bdf.drop(columns=['name']).to_csv(_b_path, index=False)
    except Exception as _e_final_billname:
        # Do not interrupt generation if this final cleanup fails
        pass
    # ------------------------------------------------------------------
# --- FINAL STEP (auto-inserted): Remove date_of_birth from visits export ---
    try:
        import pandas as _pd_final_dobfix
        v_path = os.path.join(args.outdir, "visits.csv")
        _df_final = _pd_final_dobfix.read_csv(v_path)
        if 'date_of_birth' in _df_final.columns:
            _df_final.drop(columns=['date_of_birth']).to_csv(v_path, index=False)
    except Exception as _e_final_dobfix:
        # Fail silently to avoid disrupting generation if environment lacks pandas at this point
        pass
    # --------------------------------------------------------------------------

# Validation
    summary = validate_summary(patients, visits, billing, today_str=args.today)
    with open(os.path.join(args.outdir, "validation_summary.json"), "w") as f:
        json.dump(summary, f, indent=2)
    print(json.dumps(summary, indent=2))

if __name__ == "__main__":
    main()
